// ==================== ä½ çš„ Telegram Bot Token ====================
const TELEGRAM_TOKEN = '7227202194:AAHc4KVO5CM0rdX1ghbnyaQro';

// ==================== æœ¬æœºå™¨äººçš„ User IDï¼ˆå¿…é¡»å¡«å†™ï¼‰===================
const MY_BOT_ID = 1234567890;  // â†â†â† ä¿®æ”¹ä¸ºä½ çš„æœºå™¨äººå®é™… IDï¼ˆ@userinfobot è·å–ï¼‰

// ==================== æœ¬ç¾¤å…è®¸çš„æœºå™¨äºº ID ç™½åå• ====================
const ALLOWED_BOT_IDS = [
  1234567890,     // ä½ çš„ç®¡ç† Botï¼ˆå¿…å¡«ï¼‰
  777000,         // Telegram å®˜æ–¹æœåŠ¡æ¶ˆæ¯ï¼ˆå»ºè®®åŠ ï¼‰
  // å¦‚æœ‰å…¶ä»–åˆæ³• Botï¼ŒåŠ åœ¨è¿™é‡Œ
];

// ==================== æœºå™¨äººä¸»äºº ID åˆ—è¡¨ï¼ˆæ”¯æŒå¤šä¸ªï¼‰===================
const BOT_OWNER_IDS = [123456789, 987654321];  // â†â†â† ä¿®æ”¹ä¸ºä½ ä»¬çš„ä¸»äºº ID

// ==================== è¶…é•¿åå­—é˜ˆå€¼ï¼ˆè‡ªå®šä¹‰ï¼‰===================
const MAX_NAME_LENGTH = 50;  // â†â†â† å¦‚æœåå­—ï¼ˆfirst_name + last_nameï¼‰è¶…è¿‡50å­—ç¬¦ï¼Œè§†ä¸ºåƒåœ¾åå­—

// ==================== è¿ç¦è¯å­˜å‚¨ ====================
const PROP_BANNED_WORDS = 'BANNED_WORDS';
const PROP_USER_NAMES = 'USER_NAMES';

const DEFAULT_BANNED_WORDS = [
  /TRXç§’è½¬/i,
  /å®æ—¶æµ·é€‰/i,
  /åšé’/i,
  /å…¼èŒ/i,
  /åŸèµ„æº/i,
  /æ—¥èµš/i,
  /ç§’ç»“/i,
  /å…æ‰‹ç»­/i,
  /ä½ä»·å‡º/i,
  /USDT/i,
  /æ”¶å¡/i,
  /ä»£ä»˜/i,
  /è·‘åˆ†/i
];

// ==================== åˆå§‹åŒ– ====================
function initBannedWords() {
  const props = PropertiesService.getScriptProperties();
  if (!props.getProperty(PROP_BANNED_WORDS)) {
    const list = DEFAULT_BANNED_WORDS.map(r => '/' + r.source + '/' + (r.flags || 'i'));
    props.setProperty(PROP_BANNED_WORDS, JSON.stringify(list));
  }
  if (!props.getProperty(PROP_USER_NAMES)) {
    props.setProperty(PROP_USER_NAMES, JSON.stringify({}));
  }
}

function getBannedWords() {
  const props = PropertiesService.getScriptProperties();
  let list = [];
  const stored = props.getProperty(PROP_BANNED_WORDS);
  if (stored) {
    list = JSON.parse(stored);
  } else {
    list = DEFAULT_BANNED_WORDS.map(r => '/' + r.source + '/' + (r.flags || 'i'));
    props.setProperty(PROP_BANNED_WORDS, JSON.stringify(list));
  }

  return list.map(str => {
    const match = str.match(/^\/(.*)\/(.*)$/);
    return new RegExp(match[1], match[2] || 'i');
  });
}

function addBannedWord(word) {
  if (!word || !word.trim()) return false;
  word = word.trim();

  const props = PropertiesService.getScriptProperties();
  const stored = props.getProperty(PROP_BANNED_WORDS);
  let list = stored ? JSON.parse(stored) : [];

  const escaped = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regexStr = '/' + escaped + '/i';

  if (!list.includes(regexStr)) {
    list.push(regexStr);
    props.setProperty(PROP_BANNED_WORDS, JSON.stringify(list));
    return true;
  }
  return false;
}

function removeBannedWord(index) {
  const props = PropertiesService.getScriptProperties();
  const stored = props.getProperty(PROP_BANNED_WORDS);
  if (!stored) return false;

  let list = JSON.parse(stored);
  if (index >= 0 && index < list.length) {
    list.splice(index, 1);
    props.setProperty(PROP_BANNED_WORDS, JSON.stringify(list));
    return true;
  }
  return false;
}

// ==================== ç”¨æˆ·æ˜µç§°ç®¡ç† ====================
function getUserNames(chatId) {
  const props = PropertiesService.getScriptProperties();
  const stored = props.getProperty(PROP_USER_NAMES);
  const allNames = stored ? JSON.parse(stored) : {};
  return allNames[chatId] || {};
}

function updateUserName(chatId, userId, newName) {
  const props = PropertiesService.getScriptProperties();
  const stored = props.getProperty(PROP_USER_NAMES);
  let allNames = stored ? JSON.parse(stored) : {};

  if (!allNames[chatId]) allNames[chatId] = {};

  const oldName = allNames[chatId][userId] || 'æœªçŸ¥';
  allNames[chatId][userId] = newName;

  props.setProperty(PROP_USER_NAMES, JSON.stringify(allNames));

  return oldName;
}

// ==================== Webhook è®¾ç½® ====================
function setWebhook() {
  initBannedWords();
  const url = 'https://api.telegram.org/bot' + TELEGRAM_TOKEN + '/setWebhook?url=' +
              'https://script.google.com/macros/s/AKfycbwRhSWQ8JxrMnpunuKCaydU_kuRfTHqEre5_xcIK35CaHArWBYotmbzPGBddbOHryr71A/exec';
  const res = UrlFetchApp.fetch(url);
  Logger.log(res.getContentText());
}

// ==================== è·å–ç®¡ç†å‘˜ ====================
function getAdmins(chatId) {
  const url = 'https://api.telegram.org/bot' + TELEGRAM_TOKEN + '/getChatAdministrators?chat_id=' + chatId;
  const res = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
  const data = JSON.parse(res.getContentText());
  return data.ok ? data.result.map(a => a.user.id) : [];
}

// ==================== æ°¸ä¹…å°é”ç”¨æˆ· ====================
function banUser(chatId, userId) {
  const url = 'https://api.telegram.org/bot' + TELEGRAM_TOKEN + '/banChatMember';
  const payload = {
    chat_id: chatId,
    user_id: userId,
    until_date: 0  // 0 è¡¨ç¤ºæ°¸ä¹…å°é”
  };
  const options = {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };
  UrlFetchApp.fetch(url, options);
}

// ==================== ä¸»å¤„ç†å‡½æ•° ====================
function doPost(e) {
  try {
    initBannedWords();

    const update = JSON.parse(e.postData.contents);
    const message = update.message || update.edited_message;
    const callback = update.callback_query;

    let chatId, userId, text = '', messageId;

    if (callback) {
      chatId = callback.message.chat.id;
      userId = callback.from.id;
      messageId = callback.message.message_id;

      if (!BOT_OWNER_IDS.includes(userId)) {
        answerCallback(callback.id, 'âŒ æ— æƒé™æ“ä½œ');
        return;
      }

      const data = callback.data;
      if (data === 'main_panel') editToMainPanel(chatId, messageId);
      else if (data === 'list_banned') editToBannedList(chatId, messageId);
      else if (data === 'add_banned') {
        sendAddPrompt(chatId);
        answerCallback(callback.id, 'è¯·å›å¤æœ¬æ¶ˆæ¯è¾“å…¥è¿ç¦è¯');
      } else if (data.startsWith('del_')) {
        const idx = parseInt(data.slice(4));
        if (removeBannedWord(idx)) {
          editToBannedList(chatId, messageId);
          answerCallback(callback.id, 'âœ… å·²åˆ é™¤');
        } else {
          answerCallback(callback.id, 'âŒ åˆ é™¤å¤±è´¥');
        }
      }
      answerCallback(callback.id, '');
      return;
    }

    if (message) {
      chatId = message.chat.id;
      userId = message.from.id;
      text = (message.text || '').trim();
      messageId = message.message_id;
    } else {
      return;
    }

    // ç§èŠ /settings
    if (chatId > 0 && text === '/settings') {
      if (BOT_OWNER_IDS.includes(userId)) {
        sendMainPanel(chatId);
      } else {
        sendMessage(chatId, 'âŒ ä»…æœºå™¨äººä¸»äººå¯ä½¿ç”¨æ­¤å‘½ä»¤');
      }
      return;
    }

    // ä¸»äººæ·»åŠ è¿ç¦è¯
    if (chatId > 0 && BOT_OWNER_IDS.includes(userId) && message.reply_to_message &&
        message.reply_to_message.from && message.reply_to_message.from.is_bot &&
        (message.reply_to_message.text || '').includes('è¯·å›å¤æˆ‘è¾“å…¥ä½ è¦æ·»åŠ çš„è¿ç¦è¯')) {

      if (addBannedWord(text)) {
        sendMessage(chatId, `âœ… æ·»åŠ æˆåŠŸï¼\nè¿ç¦è¯ï¼š<code>${escapeHtml(text)}</code>`);
      } else {
        sendMessage(chatId, 'âš ï¸ è¯¥è¯å·²å­˜åœ¨ï¼Œæœªé‡å¤æ·»åŠ ');
      }
      return;
    }

    // ==================== ç¾¤èŠç®¡ç†é€»è¾‘ ====================
    if (chatId < 0) {

      // å¤–éƒ¨æœºå™¨äººæ¶ˆæ¯
      if (message.from && message.from.is_bot) {
        if (!ALLOWED_BOT_IDS.includes(userId)) {
          sendMessageWithAutoDelete(chatId, 'ğŸš« æ£€æµ‹åˆ°å¤–éƒ¨æœºå™¨äººæ¶ˆæ¯ï¼Œå·²è‡ªåŠ¨åˆ é™¤ï¼Œä¿æŒç¾¤èŠå¹²å‡€', 5000);
          deleteMessage(chatId, messageId);
          return;
        }
        if (userId === MY_BOT_ID) {
          deleteMessage(chatId, messageId);
          return;
        }
      }

      // ============ æ–°å¢ï¼šå¤„ç†æ–°æˆå‘˜åŠ å…¥ï¼Œæ£€æŸ¥è¶…é•¿åƒåœ¾åå­— ============
      if (message.new_chat_members) {
        deleteMessage(chatId, messageId);  // å…ˆåˆ é™¤ç³»ç»ŸåŠ å…¥æ¶ˆæ¯ï¼ˆæ— ç—•ï¼‰
        message.new_chat_members.forEach(member => {
          if (member.is_bot) {
            // æœºå™¨äººåŠ å…¥ï¼šå¦‚æœä¸åœ¨ç™½åå•ï¼Œå°é”å¹¶æç¤º
            if (!ALLOWED_BOT_IDS.includes(member.id)) {
              banUser(chatId, member.id);
              sendMessageWithAutoDelete(chatId, `ğŸš« æ£€æµ‹åˆ°å¤–éƒ¨åƒåœ¾æœºå™¨äºº ${escapeHtml(member.first_name)} åŠ å…¥ï¼Œå·²æ°¸ä¹…å°é”`, 3000);
            }
            return;
          }

          // äººç±»ç”¨æˆ·ï¼šæ£€æŸ¥åå­—é•¿åº¦
          const fullName = (member.first_name || '') + (member.last_name ? ' ' + member.last_name : '');
          if (fullName.length > MAX_NAME_LENGTH) {
            banUser(chatId, member.id);
            sendMessageWithAutoDelete(chatId, `ğŸš« æ£€æµ‹åˆ°è¶…é•¿åƒåœ¾åå­—ç”¨æˆ· ${escapeHtml(fullName)} åŠ å…¥ï¼Œå·²æ°¸ä¹…å°é”`, 3000);
          } else {
            // æ­£å¸¸ç”¨æˆ·ï¼Œè®°å½•åå­—
            updateUserName(chatId, member.id, fullName);
          }
        });
        return;
      }

      // ç¦»å¼€ç¾¤æ— ç—•
      if (message.left_chat_member) {
        deleteMessage(chatId, messageId);
        return;
      }

      const admins = getAdmins(chatId);
      if (admins.includes(userId)) {
        checkAndNotifyNameChange(chatId, userId, message.from);
        return;
      }

      checkAndNotifyNameChange(chatId, userId, message.from);

      const content = (message.text || message.caption || '').toString();
      const banned = getBannedWords();

      if (content && banned.some(r => r.test(content))) {
        sendMessage(chatId, 'ğŸš« æ£€æµ‹åˆ°è¿ç¦å†…å®¹ï¼Œå·²åˆ é™¤æ¶ˆæ¯');
        deleteMessage(chatId, messageId);
        return;
      }

      if (message.sticker || message.animation || message.video_note) {
        sendMessage(chatId, 'ğŸš« ç¦æ­¢å‘é€è¡¨æƒ…åŒ…ã€GIF æˆ–åœ†è§†é¢‘ï¼Œå·²åˆ é™¤');
        deleteMessage(chatId, messageId);
        return;
      }

      // ç¦æ­¢å¼•ç”¨å¤–éƒ¨æ¥æº
      if (message.reply_to_message) {
        const replied = message.reply_to_message;
        const repliedChatId = replied.chat?.id || null;
        if (
          repliedChatId !== chatId ||
          replied.forward_from || replied.forward_from_chat ||
          (replied.from && replied.from.is_bot)
        ) {
          sendMessageWithAutoDelete(chatId, 'ğŸš« ç¦æ­¢å¼•ç”¨å¤–éƒ¨é¢‘é“ã€ç¾¤ç»„æˆ–æœºå™¨äººæ¶ˆæ¯ï¼Œå·²åˆ é™¤', 5000);
          deleteMessage(chatId, messageId);
          return;
        }
      }

      if (
        message.video || message.photo || message.document ||
        message.audio || message.voice || message.poll ||
        content.match(/(https?:\/\/|www\.|t\.me\/|@|\.com|\.cn|\.org|\.net)/i) ||
        message.forward_from || message.forward_from_chat ||
        update.edited_message
      ) {
        sendMessage(chatId, 'ğŸš« ç¦æ­¢å‘é€æ­¤ç±»å†…å®¹æˆ–ç¼–è¾‘æ¶ˆæ¯ï¼Œå·²åˆ é™¤');
        deleteMessage(chatId, messageId);
        return;
      }
    }

  } catch (err) {
    Logger.log('é”™è¯¯: ' + err);
  }
}

// ==================== å‘é€æ¶ˆæ¯å¹¶è‡ªåŠ¨åˆ é™¤ ====================
function sendMessageWithAutoDelete(chatId, text, delayMs = 5000) {
  const response = sendApi('sendMessage', {
    chat_id: chatId,
    text: text,
    parse_mode: 'HTML'
  });
  if (response && response.result && response.result.message_id) {
    const msgId = response.result.message_id;
    ScriptApp.newTrigger('delayedDeleteHandler')
      .timeBased()
      .after(delayMs)
      .create();
    const props = PropertiesService.getScriptProperties();
    const pending = props.getProperty('PENDING_DELETE') || '';
    const newPending = pending ? pending + ',' + chatId + ':' + msgId : chatId + ':' + msgId;
    props.setProperty('PENDING_DELETE', newPending);
  }
}

function delayedDeleteHandler() {
  const props = PropertiesService.getScriptProperties();
  const pending = props.getProperty('PENDING_DELETE');
  if (!pending) return;

  const parts = pending.split(',');
  props.deleteProperty('PENDING_DELETE');

  parts.forEach(pair => {
    const [cId, mId] = pair.split(':');
    if (cId && mId) deleteMessage(cId, parseInt(mId));
  });

  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(t => {
    if (t.getHandlerFunction() === 'delayedDeleteHandler') ScriptApp.deleteTrigger(t);
  });
}

// ==================== æ˜µç§°å˜æ›´æ£€æŸ¥ ====================
function checkAndNotifyNameChange(chatId, userId, user) {
  const currentName = (user.first_name || '') + (user.last_name ? ' ' + user.last_name : '');
  if (!currentName) return false;

  const userNames = getUserNames(chatId);
  const oldName = userNames[userId];

  if (oldName && oldName !== currentName) {
    sendMessage(chatId, `ğŸ“ æˆå‘˜ <b>${escapeHtml(oldName)}</b> å°†æ˜µç§°ä¿®æ”¹ä¸º <b>${escapeHtml(currentName)}</b>`);
    updateUserName(chatId, userId, currentName);
    return true;
  } else if (!oldName) {
    updateUserName(chatId, userId, currentName);
  }
  return false;
}

// ==================== é¢æ¿å‡½æ•° ====================
function sendMainPanel(chatId) {
  const keyboard = { inline_keyboard: [[{ text: 'ğŸ“‹ æŸ¥çœ‹è¿ç¦è¯åˆ—è¡¨', callback_data: 'list_banned' }], [{ text: 'â• æ·»åŠ è¿ç¦è¯', callback_data: 'add_banned' }]] };
  sendApi('sendMessage', { chat_id: chatId, text: 'ğŸ”§ <b>è¿ç¦è¯ç®¡ç†é¢æ¿</b>\n\nè¯·é€‰æ‹©æ“ä½œï¼š', parse_mode: 'HTML', reply_markup: JSON.stringify(keyboard) });
}

function editToMainPanel(chatId, messageId) {
  const keyboard = { inline_keyboard: [[{ text: 'ğŸ“‹ æŸ¥çœ‹è¿ç¦è¯åˆ—è¡¨', callback_data: 'list_banned' }], [{ text: 'â• æ·»åŠ è¿ç¦è¯', callback_data: 'add_banned' }]] };
  editMessage(chatId, messageId, 'ğŸ”§ <b>è¿ç¦è¯ç®¡ç†é¢æ¿</b>\n\nè¯·é€‰æ‹©æ“ä½œï¼š', keyboard);
}

function editToBannedList(chatId, messageId) {
  const words = getBannedWords();
  let text = `<b>ğŸ“‹ å½“å‰è¿ç¦è¯ (${words.length} æ¡)</b>\n\n`;
  if (words.length === 0) text += 'ï¼ˆæš‚æ— ï¼‰'; else words.forEach((r, i) => text += `${i + 1}. <code>${escapeHtml(r.source)}</code>\n`);

  const buttons = words.map((_, i) => [{ text: `ğŸ—‘ åˆ é™¤ç¬¬ ${i + 1} æ¡`, callback_data: 'del_' + i }]);
  buttons.push([{ text: 'ğŸ”™ è¿”å›ä¸»é¢æ¿', callback_data: 'main_panel' }]);

  editMessage(chatId, messageId, text, { inline_keyboard: buttons });
}

function sendAddPrompt(chatId) {
  sendApi('sendMessage', { chat_id: chatId, text: 'â• <b>æ·»åŠ è¿ç¦è¯</b>\n\nè¯·å›å¤æˆ‘è¾“å…¥ä½ è¦æ·»åŠ çš„è¿ç¦è¯ï¼ˆè‡ªåŠ¨æ¨¡ç³ŠåŒ¹é…ã€ä¸åŒºåˆ†å¤§å°å†™ï¼‰', parse_mode: 'HTML' });
}

// ==================== API å·¥å…· ====================
function sendMessage(chatId, text) {
  return sendApi('sendMessage', { chat_id: chatId, text: text, parse_mode: 'HTML' });
}

function deleteMessage(chatId, messageId) {
  sendApi('deleteMessage', { chat_id: chatId, message_id: messageId });
}

function editMessage(chatId, messageId, text, keyboard) {
  const payload = { chat_id: chatId, message_id: messageId, text: text, parse_mode: 'HTML', reply_markup: keyboard ? JSON.stringify(keyboard) : undefined };
  sendApi('editMessageText', payload);
}

function answerCallback(id, text = '') {
  sendApi('answerCallbackQuery', { callback_query_id: id, text: text, show_alert: !!text });
}

function sendApi(method, payload) {
  const url = 'https://api.telegram.org/bot' + TELEGRAM_TOKEN + '/' + method;
  const options = { method: 'post', contentType: 'application/json', payload: JSON.stringify(payload), muteHttpExceptions: true };
  try {
    const res = UrlFetchApp.fetch(url, options);
    return JSON.parse(res.getContentText());
  } catch (e) {
    Logger.log('APIé”™è¯¯ ' + method + ': ' + e);
    return null;
  }
}

function escapeHtml(t) {
  return t.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}