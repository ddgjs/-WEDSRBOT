// ========== åŸºæœ¬é…ç½® ==========
const TOKEN = 'YOUR_BOT_TOKEN'; // è¯·æ›¿æ¢ä¸ºæ‚¨çš„æœºå™¨äºº Token
const BASE_URL = `https://api.telegram.org/bot${TOKEN}/`;
const SCRIPT_URL = 'YOUR_SCRIPT_DEPLOYMENT_URL'; // è¯·æ›¿æ¢ä¸ºæ‚¨çš„ Google Apps Script éƒ¨ç½² URL
const BOT_ID = 'YOUR_BOT_ID'; // è¯·æ›¿æ¢ä¸ºæ‚¨çš„æœºå™¨äºº IDï¼ˆæ•°å­—æ ¼å¼ï¼‰
const CREATOR_ID = '123456789'; // è¯·æ›¿æ¢ä¸ºæ‚¨çš„ Telegram ID

// ========== æŒä¹…åŒ–å­˜å‚¨ ==========
const USER_LAST_MESSAGE = {};
const MESSAGE_LIMIT = 5; // 1åˆ†é’Ÿå†…æ¶ˆæ¯ä¸Šé™
const TIME_WINDOW = 60 * 1000; // 1åˆ†é’Ÿï¼ˆæ¯«ç§’ï¼‰

// ========== åˆ›å»ºè€…éªŒè¯å‡½æ•° ==========
function isCreator(userId) {
  return userId.toString() === CREATOR_ID.toString();
}

// ========== é»˜è®¤è‡ªå®šä¹‰å›å¤ ==========
const DEFAULT_CUSTOM_REPLIES = {
  "æŒ‰é’®1": { type: "text", content: "ä½ ç‚¹å‡»äº†æŒ‰é’®1ï¼Œè¿™æ˜¯è‡ªå®šä¹‰æ–‡æœ¬å›å¤ï¼", url: "" },
  "æŒ‰é’®2": { type: "photo", media: "https://via.placeholder.com/300", caption: "è¿™æ˜¯ä¸€å¼ å›¾ç‰‡ç¤ºä¾‹", url: "https://example.com/details" },
  "æŒ‰é’®3": { type: "video", media: "https://sample-videos.com/video123/mp4/720/big_buck_bunny_720p_1mb.mp4", caption: "è¿™æ˜¯ä¸€ä¸ªè§†é¢‘ç¤ºä¾‹", url: "https://example.com/video" },
  "æŒ‰é’®4": { type: "document", media: "https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf", caption: "è¿™æ˜¯ä¸€ä¸ªæ–‡æ¡£ç¤ºä¾‹", url: "https://example.com/document" },
  "æŒ‰é’®5": { type: "text", content: "ä½ ç‚¹å‡»äº†æŒ‰é’®5ï¼Œè¿™æ˜¯å¸¦é“¾æ¥æŒ‰é’®çš„å›å¤ï¼", url: "https://example.com" },
  "æŒ‰é’®6": { type: "text", content: "ä½ ç‚¹å‡»äº†æŒ‰é’®6ï¼Œè¿™æ˜¯è‡ªå®šä¹‰å›å¤ç¤ºä¾‹ï¼", url: "" },
  "è¿”å›ä¸»èœå•": { type: "text", content: "ä½ å·²è¿”å›ä¸»èœå•ï¼Œè¯·é€‰æ‹©æ–°çš„é€‰é¡¹ã€‚", url: "" },
  "é€‰é¡¹A": { type: "text", content: "ä½ é€‰æ‹©äº†é€‰é¡¹Aï¼Œè¿™æ˜¯è‡ªå®šä¹‰å›å¤ï¼", url: "" },
  "é€‰é¡¹B": { type: "text", content: "é€‰é¡¹Bå·²é€‰ä¸­ï¼Œè¯·æŸ¥çœ‹è¯¦ç»†å†…å®¹ã€‚", url: "" },
  "é€‰é¡¹C": { type: "text", content: "ä½ ç‚¹å‡»äº†é€‰é¡¹Cï¼Œç³»ç»Ÿæ­£åœ¨å¤„ç†...", url: "" },
  "é€‰é¡¹D": { type: "text", content: "ä½ é€‰æ‹©äº†é€‰é¡¹Dï¼Œè¿™æ˜¯ç‰¹åˆ«ä¿¡æ¯ã€‚", url: "" },
  "é€‰é¡¹E": { type: "text", content: "é€‰é¡¹Eè¢«é€‰ä¸­ï¼Œç³»ç»Ÿæ­£åœ¨å¤„ç†ã€‚", url: "" }
};

// ========== é»˜è®¤æ¬¢è¿æ¶ˆæ¯ï¼ˆæ”¯æŒæŒ‰é’®ï¼‰ ==========
const DEFAULT_WELCOME_MESSAGE = { type: "text", content: "æ¬¢è¿ {names} åŠ å…¥ç¾¤èŠï¼", buttons: [] };

// ========== å±æ€§å­˜å‚¨å‡½æ•° ==========
function getCustomReplies() {
  const props = PropertiesService.getScriptProperties();
  let data = props.getProperty("CUSTOM_REPLIES");
  if (!data) {
    setCustomReplies(DEFAULT_CUSTOM_REPLIES);
    return DEFAULT_CUSTOM_REPLIES;
  }
  try {
    return JSON.parse(data);
  } catch (err) {
    Logger.log("è§£æ CUSTOM_REPLIES é”™è¯¯ï¼š" + err.toString());
    return DEFAULT_CUSTOM_REPLIES;
  }
}

function setCustomReplies(obj) {
  let jsonStr = JSON.stringify(obj);
  if (jsonStr.length > 9 * 1024) throw new Error("æ•°æ®è¶…å‡º PropertiesService å•æ¡é™åˆ¶ (9KB)");
  PropertiesService.getScriptProperties().setProperty("CUSTOM_REPLIES", jsonStr);
}

function getWelcomeMessage() {
  const props = PropertiesService.getScriptProperties();
  let data = props.getProperty("WELCOME_MESSAGE");
  if (!data) {
    setWelcomeMessage(DEFAULT_WELCOME_MESSAGE);
    return DEFAULT_WELCOME_MESSAGE;
  }
  try {
    return JSON.parse(data);
  } catch (err) {
    Logger.log("è§£æ WELCOME_MESSAGE é”™è¯¯ï¼š" + err.toString());
    return DEFAULT_WELCOME_MESSAGE;
  }
}

function setWelcomeMessage(obj) {
  PropertiesService.getScriptProperties().setProperty("WELCOME_MESSAGE", JSON.stringify(obj));
}

function getSetting(key, defaultValue) {
  const props = PropertiesService.getScriptProperties();
  let value = props.getProperty(key);
  if (value === null) return defaultValue;
  if (typeof defaultValue === "boolean") return value === "true";
  if (typeof defaultValue === "number") return parseInt(value, 10);
  return value;
}

function setSetting(key, value) {
  PropertiesService.getScriptProperties().setProperty(key, value.toString());
}

// **å…·ä½“è®¾ç½®é¡¹**
function getFilterEnabled() { return getSetting("FILTER_ENABLED", true); }
function setFilterEnabled(val) { setSetting("FILTER_ENABLED", val); }
function getFuzzyMatchEnabled() { return getSetting("FUZZY_MATCH_ENABLED", true); }
function setFuzzyMatchEnabled(val) { setSetting("FUZZY_MATCH_ENABLED", val); }
function getForwardFilterEnabled() { return getSetting("FORWARD_FILTER_ENABLED", true); }
function setForwardFilterEnabled(val) { setSetting("FORWARD_FILTER_ENABLED", val); }
function getPornMediaFilterEnabled() { return getSetting("PORN_MEDIA_FILTER_ENABLED", true); }
function setPornMediaFilterEnabled(val) { setSetting("PORN_MEDIA_FILTER_ENABLED", val); }
function getWelcomeEnabled() { return getSetting("WELCOME_ENABLED", true); }
function setWelcomeEnabled(val) { setSetting("WELCOME_ENABLED", val); }
function getAdminExempt() { return getSetting("ADMIN_EXEMPT", true); }
function setAdminExempt(val) { setSetting("ADMIN_EXEMPT", val); }
function getMathVerificationEnabled() { return getSetting("MATH_VERIFICATION_ENABLED", true); }
function setMathVerificationEnabled(val) { setSetting("MATH_VERIFICATION_ENABLED", val); }
function getMuteDuration() { return getSetting("MUTE_DURATION", 3600); }
function setMuteDuration(val) { setSetting("MUTE_DURATION", val); }
function getWarningLimit() { return getSetting("WARNING_LIMIT", 3); }
function setWarningLimit(val) { setSetting("WARNING_LIMIT", val); }
function getPunishmentAutoDeleteDuration() { return getSetting("PUNISHMENT_AUTO_DELETE", 10); }
function setPunishmentAutoDeleteDuration(val) { setSetting("PUNISHMENT_AUTO_DELETE", val); }
function getEventAutoDeleteDuration() { return getSetting("EVENT_AUTO_DELETE", 10); }
function setEventAutoDeleteDuration(val) { setSetting("EVENT_AUTO_DELETE", val); }
function getWelcomeAutoDeleteDuration() { return getSetting("WELCOME_AUTO_DELETE", 0); }
function setWelcomeAutoDeleteDuration(val) { setSetting("WELCOME_AUTO_DELETE", val); }
function getReplyAutoDeleteDuration() { return getSetting("REPLY_AUTO_DELETE", 0); }
function setReplyAutoDeleteDuration(val) { setSetting("REPLY_AUTO_DELETE", val); }
function getPinAutoDeleteEnabled() { return getSetting("PIN_AUTO_DELETE_ENABLED", false); }
function setPinAutoDeleteEnabled(val) { setSetting("PIN_AUTO_DELETE_ENABLED", val); }
function getPinAutoDeleteInterval() { return getSetting("PIN_AUTO_DELETE_INTERVAL", 60); }
function setPinAutoDeleteInterval(val) { setSetting("PIN_AUTO_DELETE_INTERVAL", val); }
function getNightModeEnabled() { return getSetting("NIGHT_MODE_ENABLED", false); }
function setNightModeEnabled(val) { setSetting("NIGHT_MODE_ENABLED", val); }
function getNightModeStart() { return getSetting("NIGHT_MODE_START", "22:00"); }
function setNightModeStart(val) { setSetting("NIGHT_MODE_START", val); }
function getNightModeEnd() { return getSetting("NIGHT_MODE_END", "07:00"); }
function setNightModeEnd(val) { setSetting("NIGHT_MODE_END", val); }
function getNightModeOffset() { return getSetting("NIGHT_MODE_OFFSET", 8); }
function setNightModeOffset(val) { setSetting("NIGHT_MODE_OFFSET", val); }
function getDeleteInactiveEnabled() { return getSetting("DELETE_INACTIVE_ENABLED", false); }
function setDeleteInactiveEnabled(val) { setSetting("DELETE_INACTIVE_ENABLED", val); }

// ========== å›ºå®šé…ç½® ==========
const SPAM_KEYWORDS = ["å¹¿å‘Š", "å…è´¹", "æ¨å¹¿", "æŠ•èµ„", "èµšé’±", "ä¼˜æƒ "];
const PORN_KEYWORDS = ["è£¸éœ²", "æˆäºº", "è‰²æƒ…", "æ€§çˆ±", "æ¿€æƒ…"];
const LINK_PATTERN = /(https?:\/\/|www\.)\S+/i;
const FUZZY_THRESHOLD = 0.5;

// ========== è‡ªå®šä¹‰æ¨¡ç³Šè¿ç¦è¯å­˜å– ==========
function getFuzzyBannedWords() {
  const props = PropertiesService.getScriptProperties();
  let data = props.getProperty("FUZZY_BANNED_WORDS");
  if (!data) {
    const defaultWords = ["è‰²æƒ…", "èµŒåš", "è¯ˆéª—"];
    setFuzzyBannedWords(defaultWords);
    return defaultWords;
  }
  try {
    return JSON.parse(data);
  } catch (err) {
    Logger.log("è§£æ FUZZY_BANNED_WORDS é”™è¯¯ï¼š" + err.toString());
    return [];
  }
}

function setFuzzyBannedWords(words) {
  let jsonStr = JSON.stringify(words);
  if (jsonStr.length > 9 * 1024) throw new Error("æ¨¡ç³Šè¿ç¦è¯æ•°æ®è¶…å‡º PropertiesService å•æ¡é™åˆ¶ (9KB)");
  PropertiesService.getScriptProperties().setProperty("FUZZY_BANNED_WORDS", jsonStr);
}

// ========== è­¦å‘Šæ¬¡æ•°å­˜å– ==========
function getWarningCount(chatId, userId) {
  let key = "warn_" + chatId + "_" + userId;
  let count = PropertiesService.getScriptProperties().getProperty(key);
  return count ? parseInt(count, 10) : 0;
}

function setWarningCount(chatId, userId, count) {
  let key = "warn_" + chatId + "_" + userId;
  PropertiesService.getScriptProperties().setProperty(key, count.toString());
}

function deleteWarningCount(chatId, userId) {
  let key = "warn_" + chatId + "_" + userId;
  PropertiesService.getScriptProperties().deleteProperty(key);
}

// ========== è®°å½•ç¾¤ç»„ ==========
function recordGroup(chatId, groupTitle) {
  const props = PropertiesService.getScriptProperties();
  let groups = JSON.parse(props.getProperty("GROUPS") || "{}");
  if (!groups[chatId]) {
    groups[chatId] = groupTitle;
    props.setProperty("GROUPS", JSON.stringify(groups));
  }
}

function showGroupList(chatId) {
  const props = PropertiesService.getScriptProperties();
  let groups = JSON.parse(props.getProperty("GROUPS") || "{}");
  let text = "æœºå™¨äººæ‰€åœ¨ç¾¤ç»„åˆ—è¡¨ï¼š\n";
  for (let id in groups) {
    text += `ç¾¤ID: ${id}, åç§°: ${groups[id]}\n`;
  }
  sendMessage(chatId, text);
}

// ========== è‡ªåŠ¨åˆ é™¤æ—¶é—´å¾ªç¯å‡½æ•° ==========
function cycleWelcomeAutoDelete(chatId, messageId) {
  const durations = [0, 5, 10, 20, 30];
  let current = getWelcomeAutoDeleteDuration();
  let idx = durations.indexOf(current);
  if (idx === -1) idx = 0;
  let newDuration = durations[(idx + 1) % durations.length];
  setWelcomeAutoDeleteDuration(newDuration);
  Logger.log("æ›´æ–°æ¬¢è¿æ¶ˆæ¯è‡ªåŠ¨åˆ é™¤æ—¶é•¿ï¼Œä» " + current + " ç§’åˆ° " + newDuration + " ç§’");
  editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
}

function cycleReplyAutoDelete(chatId, messageId) {
  const durations = [0, 60, 120, 300, 600]; // 0, 1, 2, 5, 10 åˆ†é’Ÿï¼ˆå•ä½ï¼šç§’ï¼‰
  let current = getReplyAutoDeleteDuration();
  let idx = durations.indexOf(current);
  if (idx === -1) idx = 0;
  let newDuration = durations[(idx + 1) % durations.length];
  setReplyAutoDeleteDuration(newDuration);
  Logger.log("æ›´æ–°å…³é”®è¯å›å¤è‡ªåŠ¨åˆ é™¤æ—¶é•¿ï¼Œä» " + current + " ç§’åˆ° " + newDuration + " ç§’");
  editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
}

// ========== ç½®é¡¶æ¶ˆæ¯è‡ªåŠ¨åˆ é™¤ ==========
function deletePinnedMessages() {
  const props = PropertiesService.getScriptProperties();
  let groups = JSON.parse(props.getProperty("GROUPS") || "{}");
  Logger.log(`å¼€å§‹æ£€æŸ¥ç½®é¡¶æ¶ˆæ¯ï¼Œç¾¤ç»„åˆ—è¡¨: ${JSON.stringify(groups)}`);
  
  for (let chatId in groups) {
    try {
      let pinnedMessage = getPinnedMessage(chatId);
      if (pinnedMessage) {
        let result = deleteMessage(chatId, pinnedMessage.message_id);
        if (result) {
          Logger.log(`æˆåŠŸåˆ é™¤ç¾¤ ${chatId} çš„ç½®é¡¶æ¶ˆæ¯ ${pinnedMessage.message_id}`);
        } else {
          Logger.log(`åˆ é™¤ç¾¤ ${chatId} çš„ç½®é¡¶æ¶ˆæ¯ ${pinnedMessage.message_id} å¤±è´¥ï¼Œå¯èƒ½æ˜¯æƒé™ä¸è¶³æˆ–æ¶ˆæ¯å·²ä¸å­˜åœ¨`);
        }
      } else {
        Logger.log(`ç¾¤ ${chatId} æ— ç½®é¡¶æ¶ˆæ¯æˆ–è·å–å¤±è´¥`);
      }
    } catch (err) {
      Logger.log(`å¤„ç†ç¾¤ ${chatId} çš„ç½®é¡¶æ¶ˆæ¯æ—¶å‡ºé”™: ${err.toString()}`);
    }
  }
}

function getPinnedMessage(chatId) {
  let response = sendRequest("getChat", { chat_id: chatId });
  Logger.log(`è·å–ç¾¤ ${chatId} ç½®é¡¶æ¶ˆæ¯å“åº”: ${JSON.stringify(response)}`);
  if (response && response.ok && response.result.pinned_message) {
    return response.result.pinned_message;
  }
  return null;
}

function setupPinAutoDeleteTrigger() {
  deleteTriggers("deletePinnedMessages");
  if (getPinAutoDeleteEnabled()) {
    let interval = getPinAutoDeleteInterval();
    try {
      ScriptApp.newTrigger("deletePinnedMessages")
        .timeBased()
        .everyMinutes(interval)
        .create();
      Logger.log(`ç½®é¡¶è‡ªåŠ¨åˆ é™¤è§¦å‘å™¨å·²è®¾ç½®ä¸ºæ¯ ${interval} åˆ†é’Ÿè¿è¡Œ`);
    } catch (err) {
      Logger.log(`è®¾ç½®ç½®é¡¶è‡ªåŠ¨åˆ é™¤è§¦å‘å™¨å¤±è´¥: ${err.toString()}`);
    }
  } else {
    Logger.log("ç½®é¡¶è‡ªåŠ¨åˆ é™¤å·²å…³é—­ï¼Œæ— éœ€è®¾ç½®è§¦å‘å™¨");
  }
}

function deleteTriggers(functionName) {
  let triggers = ScriptApp.getProjectTriggers();
  for (let trigger of triggers) {
    if (trigger.getHandlerFunction() === functionName) {
      ScriptApp.deleteTrigger(trigger);
      Logger.log(`å·²åˆ é™¤è§¦å‘å™¨: ${functionName}`);
    }
  }
}

// ========== å¤œé—´æ¨¡å¼ ==========
function isNightModeActive() {
  if (!getNightModeEnabled()) return false;
  let now = new Date();
  let offsetHours = getNightModeOffset();
  let localNow = new Date(now.getTime() + offsetHours * 3600 * 1000);
  let start = parseTime(getNightModeStart(), offsetHours);
  let end = parseTime(getNightModeEnd(), offsetHours);
  let nowMinutes = localNow.getHours() * 60 + localNow.getMinutes();
  let startMinutes = start.getHours() * 60 + start.getMinutes();
  let endMinutes = end.getHours() * 60 + end.getMinutes();
  if (startMinutes < endMinutes) return nowMinutes >= startMinutes && nowMinutes < endMinutes;
  return nowMinutes >= startMinutes || nowMinutes < endMinutes;
}

function parseTime(timeStr, offsetHours) {
  let [hours, minutes] = timeStr.split(":").map(Number);
  let date = new Date();
  date.setUTCHours(hours - offsetHours, minutes, 0, 0);
  return date;
}

// ========== æœªéªŒè¯ç”¨æˆ·æ£€æŸ¥ ==========
function checkUnverifiedUsers() {
  const props = PropertiesService.getScriptProperties();
  const now = Math.floor(Date.now() / 1000);
  const allProps = props.getProperties();
  Logger.log("å¼€å§‹æ£€æŸ¥æœªéªŒè¯ç”¨æˆ·...");
  for (let key in allProps) {
    if (key.startsWith("JOIN_DATA_")) {
      const dataStr = allProps[key];
      const joinData = JSON.parse(dataStr);
      const parts = key.split("_");
      const chatId = parts[2];
      const userId = parts[3];
      if (now - joinData.time > 60) {
        const verified = getVerifiedStatus(chatId, userId);
        Logger.log(`æ£€æŸ¥ç”¨æˆ· ${userId} åœ¨ç¾¤ ${chatId}: åŠ å…¥æ—¶é—´=${joinData.time}, å½“å‰æ—¶é—´=${now}, å·²éªŒè¯=${verified}`);
        if (verified !== "true" && userId !== BOT_ID) {
          let result = banUser(chatId, userId);
          if (result) {
            const firstName = joinData.firstName;
            const mention = `<a href="tg://user?id=${userId}">${firstName}</a>`;
            const muteMessage = `${mention} ç”±äºæœªé€šè¿‡éªŒè¯å·²è¢«æ°¸ä¹…ç¦è¨€ï¼Œè¯·è”ç³»ç¾¤ä¸» @CMKOW è§£é™¤ç¦è¨€ã€‚`;
            sendAutoDeleteMessage(chatId, muteMessage, 10, { parse_mode: "HTML" });
            if (joinData.verificationMessageId) {
              deleteMessage(chatId, joinData.verificationMessageId);
            }
          } else {
            Logger.log(`ç¦è¨€ç”¨æˆ· ${userId} åœ¨ç¾¤ ${chatId} å¤±è´¥ï¼Œå¯èƒ½ç¼ºå°‘æƒé™`);
          }
          deleteJoinData(chatId, userId);
          deleteVerifiedStatus(chatId, userId);
          deleteMathVerifyAnswer(chatId, userId);
        }
      }
    }
  }
  Logger.log("æœªéªŒè¯ç”¨æˆ·æ£€æŸ¥å®Œæˆ");
}

// ========== åŠ å…¥æ•°æ®å­˜å–ï¼ˆæ–°å¢ verificationMessageIdï¼‰ ==========
function setJoinData(chatId, userId, time, firstName, verificationMessageId) {
  const key = `JOIN_DATA_${chatId}_${userId}`;
  const data = { time: time, firstName: firstName, verificationMessageId: verificationMessageId };
  PropertiesService.getScriptProperties().setProperty(key, JSON.stringify(data));
}

function getJoinData(chatId, userId) {
  const key = `JOIN_DATA_${chatId}_${userId}`;
  const dataStr = PropertiesService.getScriptProperties().getProperty(key);
  return dataStr ? JSON.parse(dataStr) : null;
}

function deleteJoinData(chatId, userId) {
  const key = `JOIN_DATA_${chatId}_${userId}`;
  PropertiesService.getScriptProperties().deleteProperty(key);
}

// ========== æ•°å­¦éªŒè¯ç­”æ¡ˆå­˜å– ==========
function setMathVerifyAnswer(chatId, userId, answer) {
  const key = `MATH_VERIFY_${chatId}_${userId}`;
  PropertiesService.getScriptProperties().setProperty(key, answer);
}

function getMathVerifyAnswer(chatId, userId) {
  const key = `MATH_VERIFY_${chatId}_${userId}`;
  return PropertiesService.getScriptProperties().getProperty(key);
}

function deleteMathVerifyAnswer(chatId, userId) {
  const key = `MATH_VERIFY_${chatId}_${userId}`;
  PropertiesService.getScriptProperties().deleteProperty(key);
}

// ========== éªŒè¯çŠ¶æ€å­˜å– ==========
function setVerifiedStatus(chatId, userId, status) {
  const key = `VERIFIED_${chatId}_${userId}`;
  PropertiesService.getScriptProperties().setProperty(key, status);
}

function getVerifiedStatus(chatId, userId) {
  const key = `VERIFIED_${chatId}_${userId}`;
  return PropertiesService.getScriptProperties().getProperty(key);
}

function deleteVerifiedStatus(chatId, userId) {
  const key = `VERIFIED_${chatId}_${userId}`;
  PropertiesService.getScriptProperties().deleteProperty(key);
}

// ========== åƒåœ¾çŸ­è¯­å­˜å‚¨ ==========
function getSpamPhrases() {
  const props = PropertiesService.getScriptProperties();
  let data = props.getProperty("SPAM_PHRASES");
  if (!data) {
    const defaultSpamPhrases = [
      "æ‰“æ¡©è¯ ğŸ’Š", "çœ‹èµ„æ–™ æ—¥2000+ æ¶äºº", "ç‚¹æˆ‘å¤´åƒç®€ä»‹å…¥ç¾¤", "å­¦ç”Ÿ èè‰ å°‘å¦‡ åº”æœ‰å°½æœ‰ å°½åœ¨ç®€ä»‹æŸ¥çœ‹",
      "åˆçº¦è·Ÿå•", "ç¢æœˆğŸˆ·ï¸", "æ·˜å®åˆ·é‡ä¸€å•ä¸€æ¥", "æœˆå…¥8oooo æ‹›äººåšæŠ–éŸ³å°åº—æ´—èµ„", "Gn/tv/tf/gv",
      "ğŸ”¥å…è´¹,æ— å¥—è·¯ğŸ’»å‘¦å¥³ğŸ’»æ—¥æœ¬å¥³ä¼˜â¤ï¸å¤©ä¸Šäººé—´ğŸå¥¸æ·«ğŸ”¥ç ´å¤„ğŸ‰èè‰"
    ];
    setSpamPhrases(defaultSpamPhrases);
    return defaultSpamPhrases;
  }
  try {
    return JSON.parse(data);
  } catch (err) {
    Logger.log("è§£æ SPAM_PHRASES é”™è¯¯ï¼š" + err.toString());
    return [];
  }
}

function setSpamPhrases(phrases) {
  PropertiesService.getScriptProperties().setProperty("SPAM_PHRASES", JSON.stringify(phrases));
}

function containsSpamPhrase(name, phrases) {
  const lowerName = name.toLowerCase();
  return phrases.some(phrase => lowerName.includes(phrase.toLowerCase()));
}

// ========== è¸¢å‡ºç”¨æˆ· ==========
function kickUser(chatId, userId) {
  sendRequest("banChatMember", { chat_id: chatId, user_id: userId });
}

// ========== å®šæ—¶ä»»åŠ¡å­˜å‚¨å’Œç®¡ç† ==========
function getScheduledTasks() {
  const props = PropertiesService.getScriptProperties();
  let data = props.getProperty("SCHEDULED_TASKS");
  if (!data) return [];
  try {
    return JSON.parse(data);
  } catch (err) {
    Logger.log("è§£æ SCHEDULED_TASKS é”™è¯¯ï¼š" + err.toString());
    return [];
  }
}

function setScheduledTasks(tasks) {
  let jsonStr = JSON.stringify(tasks);
  if (jsonStr.length > 9 * 1024) throw new Error("å®šæ—¶æ¶ˆæ¯æ•°æ®è¶…å‡º PropertiesService å•æ¡é™åˆ¶ (9KB)");
  PropertiesService.getScriptProperties().setProperty("SCHEDULED_TASKS", jsonStr);
}

function addScheduledTask(task) {
  let tasks = getScheduledTasks();
  if (tasks.length >= 20) throw new Error("å®šæ—¶æ¶ˆæ¯æ•°é‡å·²è¾¾ä¸Šé™ (20æ¡)");
  task.id = Utilities.getUuid();
  tasks.push(task);
  setScheduledTasks(tasks);
}

function updateScheduledTask(id, updates) {
  let tasks = getScheduledTasks();
  let task = tasks.find(t => t.id === id);
  if (!task) throw new Error("å®šæ—¶æ¶ˆæ¯ä¸å­˜åœ¨");
  Object.assign(task, updates);
  setScheduledTasks(tasks);
}

function deleteScheduledTask(id) {
  let tasks = getScheduledTasks();
  let index = tasks.findIndex(t => t.id === id);
  if (index !== -1) {
    tasks.splice(index, 1);
    setScheduledTasks(tasks);
  }
}

function checkScheduledTasks() {
  let now = new Date().getTime();
  let tasks = getScheduledTasks();
  let updated = false;
  let result;

  tasks.forEach(task => {
    if (task.time <= now) {
      if (task.lastMessageId) deleteMessage(task.chatId, task.lastMessageId);
      let inlineKeyboard = task.buttons.map(btn => [{ text: btn.text, url: btn.url }]);
      let options = { reply_markup: { inline_keyboard: inlineKeyboard } };
      if (task.type !== "text" && task.caption) options.caption = task.caption;

      switch (task.type) {
        case "text":
          result = sendMessage(task.chatId, task.content, options);
          break;
        case "photo":
          result = sendPhoto(task.chatId, task.content, options);
          break;
        case "video":
          result = sendVideo(task.chatId, task.content, options);
          break;
        case "document":
          result = sendDocument(task.chatId, task.content, options);
          break;
        case "audio":
          result = sendAudio(task.chatId, task.content, options);
          break;
        default:
          Logger.log("æœªçŸ¥çš„æ¶ˆæ¯ç±»å‹: " + task.type);
          return;
      }
      if (result && result.ok && result.result && result.result.message_id) task.lastMessageId = result.result.message_id;
      if (task.repeat !== "none") {
        let nextTime = calculateNextTime(task.time, task.repeat);
        task.time = nextTime;
        updated = true;
      } else {
        deleteScheduledTask(task.id);
        updated = true;
      }
    }
  });
  if (updated) setScheduledTasks(tasks);
}

function calculateNextTime(currentTime, repeat) {
  let date = new Date(currentTime);
  switch (repeat) {
    case "hourly": date.setHours(date.getHours() + 1); break;
    case "daily": date.setDate(date.getDate() + 1); break;
    case "weekly": date.setDate(date.getDate() + 7); break;
    case "monthly": date.setMonth(date.getMonth() + 1); break;
    default: return currentTime;
  }
  return date.getTime();
}

function setupScheduledTaskTrigger() {
  deleteTriggers("checkScheduledTasks");
  ScriptApp.newTrigger("checkScheduledTasks").timeBased().everyMinutes(1).create();
  Logger.log("å®šæ—¶ä»»åŠ¡è§¦å‘å™¨å·²è®¾ç½®ä¸ºæ¯åˆ†é’Ÿè¿è¡Œ");
}

function sendTaskSetupMessage(chatId, step, taskData) {
  let prompts = {
    "chatId": "è¯·å‘é€ç›®æ ‡ç¾¤IDï¼ˆä¾‹å¦‚ -123456789ï¼‰",
    "time": "è¯·å‘é€å‘é€æ—¶é—´ï¼ˆæ ¼å¼ï¼šYYYY-MM-DD HH:MM:SSï¼‰",
    "type": "è¯·å‘é€æ¶ˆæ¯ç±»å‹ï¼ˆtext, photo, video, audio, documentï¼‰",
    "content": "è¯·å‘é€æ¶ˆæ¯å†…å®¹ï¼ˆå¯¹äºtextæ˜¯æ–‡æœ¬ï¼Œå¯¹äºå…¶ä»–æ˜¯åª’ä½“URLï¼‰",
    "buttons": "è¯·å‘é€æŒ‰é’®æ–‡æœ¬å’ŒURLï¼Œç”¨é€—å·åˆ†éš”å¤šä¸ªæŒ‰é’®ï¼ˆæ ¼å¼ï¼šæ–‡æœ¬1,URL1,æ–‡æœ¬2,URL2,...ï¼‰",
    "repeat": "è¯·å‘é€é‡å¤å‘¨æœŸï¼ˆnone, hourly, daily, weekly, monthlyï¼‰",
    "caption": "è¯·å‘é€captionï¼ˆå¯é€‰ï¼Œä»…å¯¹étextç±»å‹æœ‰æ•ˆï¼ŒæŒ‰ Enter è·³è¿‡ï¼‰"
  };
  sendMessage(chatId, prompts[step]);
  let cache = CacheService.getScriptCache();
  cache.put("TASK_SETUP_" + chatId, JSON.stringify({ step: step, data: taskData }), 300);
}

// ========== åˆ é™¤å·²é”€å·ç”¨æˆ· ==========
function checkAndRemoveInactiveUsers() {
  if (!getDeleteInactiveEnabled()) return;
  const props = PropertiesService.getScriptProperties();
  let groups = JSON.parse(props.getProperty("GROUPS") || "{}");
  for (let chatId in groups) {
    let members = getChatMembers(chatId);
    if (members && members.length > 0) {
      members.forEach(member => {
        if (member.user.is_deleted) {
          kickUser(chatId, member.user.id);
          sendMessage(chatId, `å·²ç§»é™¤å·²é”€å·ç”¨æˆ· ${member.user.id}`);
          Logger.log(`ä»ç¾¤ ${chatId} ç§»é™¤å·²é”€å·ç”¨æˆ· ${member.user.id}`);
        }
      });
    } else {
      Logger.log(`ç¾¤ ${chatId} æ— ç®¡ç†å‘˜æ•°æ®æˆ–æ— æ³•è·å–æˆå‘˜åˆ—è¡¨ï¼Œä»…èƒ½æ£€æµ‹ç®¡ç†å‘˜çš„å·²é”€å·çŠ¶æ€`);
    }
  }
  Logger.log("æ³¨æ„ï¼šå½“å‰å®ç°ä»…æ£€æŸ¥ç®¡ç†å‘˜çš„å·²é”€å·çŠ¶æ€ï¼Œå›  Telegram API é™åˆ¶æ— æ³•è‡ªåŠ¨æ£€æµ‹æ‰€æœ‰æˆå‘˜");
}

function getChatMembers(chatId) {
  let response = sendRequest("getChatAdministrators", { chat_id: chatId });
  if (response && response.ok) return response.result;
  return [];
}

function setupInactiveUserTrigger() {
  deleteTriggers("checkAndRemoveInactiveUsers");
  if (getDeleteInactiveEnabled()) {
    try {
      ScriptApp.newTrigger("checkAndRemoveInactiveUsers")
        .timeBased()
        .everyHours(24)
        .create();
      Logger.log("å·²é”€å·ç”¨æˆ·æ£€æŸ¥è§¦å‘å™¨å·²è®¾ç½®ä¸ºæ¯å¤©è¿è¡Œ");
    } catch (err) {
      Logger.log(`è®¾ç½®å·²é”€å·ç”¨æˆ·æ£€æŸ¥è§¦å‘å™¨å¤±è´¥: ${err.toString()}`);
    }
  }
}

// ========== é˜²æ­¢åˆ·å±å‡½æ•° ==========
function checkAndHandleSpam(chatId, userId, timestamp, messageId) {
  let timeKey = `MSG_TIMES_${chatId}_${userId}`;
  let idKey = `MSG_IDS_${chatId}_${userId}`;
  let props = PropertiesService.getScriptProperties();
  let timesStr = props.getProperty(timeKey);
  let times = timesStr ? JSON.parse(timesStr) : [];
  let msgIdsStr = props.getProperty(idKey);
  let msgIds = msgIdsStr ? JSON.parse(msgIdsStr) : [];

  let now = timestamp;
  times = times.filter(t => now - t < TIME_WINDOW);
  times.push(now);
  msgIds.push(messageId);

  if (times.length > MESSAGE_LIMIT) {
    msgIds.forEach(id => deleteMessage(chatId, id));
    banUser(chatId, userId);
    sendMessage(chatId, `ç”¨æˆ· ${userId} å› åˆ·å±è¢«æ°¸ä¹…ç¦è¨€ã€‚`);
    props.deleteProperty(timeKey);
    props.deleteProperty(idKey);
  } else {
    props.setProperty(timeKey, JSON.stringify(times));
    props.setProperty(idKey, JSON.stringify(msgIds));
  }
}

// ========== æ¸…é™¤ç”¨æˆ·æ“ä½œç¼“å­˜ ==========
function clearUserOperations(senderId) {
  let cache = CacheService.getScriptCache();
  cache.remove("ADD_reply_" + senderId);
  cache.remove("TEMP_FUZZY_" + senderId);
  cache.remove("TEMP_WELCOME_" + senderId);
  cache.remove("EDIT_WELCOME_" + senderId);
  cache.remove("EDIT_TASK_" + senderId);
  cache.remove("EDIT_TASK_CONTENT_" + senderId);
}

// ========== ä¸»å¤„ç†å‡½æ•° ==========
function doPost(e) {
  try {
    if (!e || !e.postData || !e.postData.contents) return;
    const update = JSON.parse(e.postData.contents);
    if (update.callback_query) return handleCallback(update.callback_query);
    if (update.chat_member) {
      const chatMember = update.chat_member;
      const user = chatMember.new_chat_member.user;
      if (user.is_deleted && getDeleteInactiveEnabled()) {
        kickUser(chatMember.chat.id, user.id);
        sendMessage(chatMember.chat.id, `å·²åˆ é™¤å·²é”€å·ç”¨æˆ· ${user.id}`);
      }
      return handleChatMemberUpdate(update.chat_member);
    }
    if (!update.message) return;

    const message = update.message;
    const chatId = message.chat.id;
    const senderId = message.from.id;
    const text = message.text;
    const message_id = message.message_id;
    const timestamp = message.date * 1000;
    Logger.log(`æ”¶åˆ°æ¶ˆæ¯ï¼šchatId=${chatId}, senderId=${senderId}, text=${text}`);

    if (message.pinned_message) {
      deleteMessage(chatId, message_id);
      Logger.log(`åˆ é™¤ç³»ç»Ÿç½®é¡¶æ¶ˆæ¯é€šçŸ¥: chatId=${chatId}, messageId=${message_id}`);
    }

    if (chatId < 0) {
      recordGroup(chatId, message.chat.title || "æœªçŸ¥ç¾¤ç»„");
      checkAndHandleSpam(chatId, senderId, timestamp, message_id);
    }
    let isSenderAdmin = isAdmin(chatId, senderId);

    if (message.entities) {
      const firstEntity = message.entities[0];
      if (firstEntity.type === "bot_command" && firstEntity.offset === 0) {
        const command = text.substring(firstEntity.offset, firstEntity.offset + firstEntity.length);
        const commandName = command.split("@")[0];
        if (commandName === "/start") return sendMenu(chatId);
        else if (commandName === "/help") return sendHelpMessage(chatId);
        else if (commandName === "/settings") {
          if (!isCreator(senderId)) {
            sendMessage(chatId, "âŒ åªæœ‰æœºå™¨äººåˆ›å»ºè€…å¯ä»¥ä½¿ç”¨è¯¥å‘½ä»¤");
            return;
          }
          return sendSettingsMenu(chatId);
        }
        else if (commandName === "/ban") {
          if (!isSenderAdmin) {
            sendMessage(chatId, "âŒ åªæœ‰ç®¡ç†å‘˜å¯ä»¥ä½¿ç”¨è¯¥å‘½ä»¤");
            return;
          }
          let targetUserId;
          if (message.reply_to_message && message.reply_to_message.from) {
            targetUserId = message.reply_to_message.from.id;
          } else {
            let parts = text.split(" ");
            if (parts.length < 2) {
              sendMessage(chatId, "è¯·å›å¤è¦ç¦è¨€çš„ç”¨æˆ·æ¶ˆæ¯ï¼Œæˆ–è€…ä½¿ç”¨æ ¼å¼ï¼š/ban ç”¨æˆ·ID");
              return;
            }
            targetUserId = parts[1].trim();
          }
          if (targetUserId === BOT_ID) {
            sendMessage(chatId, "âŒ ä¸èƒ½ç¦è¨€æœºå™¨äºº");
            return;
          }
          let result = banUser(chatId, targetUserId);
          if (result) {
            sendMessage(chatId, `ç”¨æˆ· ${targetUserId} å·²è¢«æ°¸ä¹…ç¦è¨€`);
          } else {
            sendMessage(chatId, `ç¦è¨€ç”¨æˆ· ${targetUserId} å¤±è´¥ï¼Œå¯èƒ½ç¼ºå°‘æƒé™`);
          }
          return;
        }
        else if (commandName === "/myid") {
          sendMessage(chatId, `æ‚¨çš„ç”¨æˆ·IDæ˜¯ï¼š${senderId}`);
          return;
        }
        else if (commandName === "/addscheduledmsg") {
          if (!isCreator(senderId)) {
            sendMessage(chatId, "âŒ åªæœ‰æœºå™¨äººåˆ›å»ºè€…å¯ä»¥ä½¿ç”¨è¯¥å‘½ä»¤");
            return;
          }
          let params = text.substring(16).trim().split("|");
          if (params.length < 7) {
            sendMessage(chatId, "æ ¼å¼é”™è¯¯ã€‚ä½¿ç”¨ï¼š/addscheduledmsg ç¾¤ID|æ—¶é—´|ç±»å‹|å†…å®¹|æŒ‰é’®æ–‡æœ¬1,æŒ‰é’®æ–‡æœ¬2|æŒ‰é’®URL1,æŒ‰é’®URL2|é‡å¤å‘¨æœŸ[|caption]");
            return;
          }
          let targetChatId = params[0].trim();
          let timeStr = params[1].trim();
          let type = params[2].trim();
          let content = params[3].trim();
          let buttonTexts = params[4].split(",").map(t => t.trim());
          let buttonUrls = params[5].split(",").map(u => u.trim());
          let repeat = params[6].trim().toLowerCase();
          let caption = params.length > 7 ? params[7].trim() : "";
          if (buttonTexts.length !== buttonUrls.length) {
            sendMessage(chatId, "æŒ‰é’®æ–‡æœ¬å’ŒURLæ•°é‡ä¸åŒ¹é…");
            return;
          }
          let sendTime = new Date(timeStr);
          if (isNaN(sendTime.getTime())) {
            sendMessage(chatId, "æ—¶é—´æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨ YYYY-MM-DD HH:MM:SS");
            return;
          }
          if (!["none", "hourly", "daily", "weekly", "monthly"].includes(repeat)) {
            sendMessage(chatId, "é‡å¤å‘¨æœŸé”™è¯¯ï¼Œå¯ç”¨å€¼ï¼šnone, hourly, daily, weekly, monthly");
            return;
          }
          let buttons = [];
          for (let i = 0; i < buttonTexts.length; i++) buttons.push({ text: buttonTexts[i], url: buttonUrls[i] });
          let task = { chatId: targetChatId, time: sendTime.getTime(), type: type, content: content, buttons: buttons, repeat: repeat, caption: caption, lastMessageId: null };
          try {
            addScheduledTask(task);
            sendMessage(chatId, "å®šæ—¶ä»»åŠ¡å·²æ·»åŠ ã€‚");
          } catch (err) {
            sendMessage(chatId, err.message);
          }
          return;
        }
        else if (commandName === "/addspam") {
          if (!isCreator(senderId)) {
            sendMessage(chatId, "âŒ åªæœ‰æœºå™¨äººåˆ›å»ºè€…å¯ä»¥ä½¿ç”¨è¯¥å‘½ä»¤");
            return;
          }
          let phrase = text.substring(8).trim();
          if (phrase) {
            let spamPhrases = getSpamPhrases();
            if (spamPhrases.indexOf(phrase) === -1) {
              spamPhrases.push(phrase);
              setSpamPhrases(spamPhrases);
              sendMessage(chatId, `åƒåœ¾çŸ­è¯­ "${phrase}" å·²æ·»åŠ ã€‚`);
            } else sendMessage(chatId, `åƒåœ¾çŸ­è¯­ "${phrase}" å·²å­˜åœ¨ã€‚`);
          } else sendMessage(chatId, "è¯·æä¾›è¦æ·»åŠ çš„åƒåœ¾çŸ­è¯­ã€‚");
          return;
        }
        else if (commandName === "/delspam") {
          if (!isCreator(senderId)) {
            sendMessage(chatId, "âŒ åªæœ‰æœºå™¨äººåˆ›å»ºè€…å¯ä»¥ä½¿ç”¨è¯¥å‘½ä»¤");
            return;
          }
          let phrase = text.substring(8).trim();
          if (phrase) {
            let spamPhrases = getSpamPhrases();
            let index = spamPhrases.indexOf(phrase);
            if (index !== -1) {
              spamPhrases.splice(index, 1);
              setSpamPhrases(spamPhrases);
              sendMessage(chatId, `åƒåœ¾çŸ­è¯­ "${phrase}" å·²åˆ é™¤ã€‚`);
            } else sendMessage(chatId, `åƒåœ¾çŸ­è¯­ "${phrase}" ä¸å­˜åœ¨ã€‚`);
          } else sendMessage(chatId, "è¯·æä¾›è¦åˆ é™¤çš„åƒåœ¾çŸ­è¯­ã€‚");
          return;
        }
        else if (commandName === "/listspam") {
          if (!isCreator(senderId)) {
            sendMessage(chatId, "âŒ åªæœ‰æœºå™¨äººåˆ›å»ºè€…å¯ä»¥ä½¿ç”¨è¯¥å‘½ä»¤");
            return;
          }
          let spamPhrases = getSpamPhrases();
          if (spamPhrases.length === 0) {
            sendMessage(chatId, "æš‚æ— åƒåœ¾çŸ­è¯­ã€‚");
          } else {
            let listText = "ã€åƒåœ¾çŸ­è¯­åˆ—è¡¨ã€‘\n";
            spamPhrases.forEach(phrase => {
              listText += `- ${phrase}\n`;
            });
            sendMessage(chatId, listText);
          }
          return;
        }
        else if (commandName === "/setnightmode") {
          if (!isCreator(senderId)) {
            sendMessage(chatId, "âŒ åªæœ‰æœºå™¨äººåˆ›å»ºè€…å¯ä»¥ä½¿ç”¨è¯¥å‘½ä»¤");
            return;
          }
          let parts = text.split(" ");
          if (parts.length < 2) return sendMessage(chatId, "æ ¼å¼é”™è¯¯ï¼Œä½¿ç”¨ï¼š/setnightmode on å¼€å§‹æ—¶é—´ ç»“æŸæ—¶é—´ æ—¶åŒºåç§» æˆ– /setnightmode off\nä¾‹å¦‚ï¼š/setnightmode on 22:00 07:00 UTC+8");
          let state = parts[1].toLowerCase();
          if (state === "off") {
            setNightModeEnabled(false);
            return sendMessage(chatId, "å¤œé—´æ¨¡å¼å·²å…³é—­ã€‚");
          }
          else if (state === "on") {
            if (parts.length < 5) return sendMessage(chatId, "æ ¼å¼é”™è¯¯ï¼Œä½¿ç”¨ï¼š/setnightmode on å¼€å§‹æ—¶é—´ ç»“æŸæ—¶é—´ æ—¶åŒºåç§»\nä¾‹å¦‚ï¼š/setnightmode on 22:00 07:00 UTC+8");
            let startTime = parts[2];
            let endTime = parts[3];
            let timezone = parts[4].toUpperCase();
            if (!/^\d{2}:\d{2}$/.test(startTime) || !/^\d{2}:\d{2}$/.test(endTime)) return sendMessage(chatId, "æ—¶é—´æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨ HH:MMï¼Œå¦‚ 22:00");
            if (!/^UTC[+-]\d{1,2}$/.test(timezone)) return sendMessage(chatId, "æ—¶åŒºæ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨ UTC+8 æˆ– UTC-8 ç­‰æ ¼å¼");
            let offset = parseInt(timezone.replace("UTC", ""), 10);
            setNightModeEnabled(true);
            setNightModeStart(startTime);
            setNightModeEnd(endTime);
            setNightModeOffset(offset);
            return sendMessage(chatId, `å¤œé—´æ¨¡å¼å·²å¯ç”¨ï¼Œä» ${startTime} åˆ° ${endTime}ï¼Œæ—¶åŒº ${timezone}ã€‚`);
          }
          else return sendMessage(chatId, "æ— æ•ˆå‚æ•°ï¼Œä½¿ç”¨ï¼š/setnightmode on å¼€å§‹æ—¶é—´ ç»“æŸæ—¶é—´ æ—¶åŒºåç§» æˆ– /setnightmode off");
        }
      }
    }

    if (chatId < 0 && isNightModeActive() && !isSenderAdmin) {
      deleteMessage(chatId, message_id);
      sendAutoDeleteMessage(chatId, "å¤œé—´æ¨¡å¼å·²å¯ç”¨ï¼Œéç®¡ç†å‘˜æ¶ˆæ¯å°†è¢«åˆ é™¤ã€‚", 10);
      return;
    }

    if (chatId < 0 && text) {
      let expectedAnswer = getMathVerifyAnswer(chatId, senderId);
      if (expectedAnswer !== null) {
        if (/^\d+$/.test(text) && text === expectedAnswer) {
          deleteMathVerifyAnswer(chatId, senderId);
          setVerifiedStatus(chatId, senderId, "true");
          let joinData = getJoinData(chatId, senderId);
          if (joinData && joinData.verificationMessageId) {
            deleteMessage(chatId, joinData.verificationMessageId);
          }
          deleteMessage(chatId, message_id);
          sendMessage(chatId, "éªŒè¯é€šè¿‡ï¼Œæ¬¢è¿åŠ å…¥ç¾¤èŠï¼");
          if (getWelcomeEnabled()) sendCustomWelcome(chatId, [message.from]);
          deleteJoinData(chatId, senderId);
        } else {
          sendMessage(chatId, "ç­”æ¡ˆé”™è¯¯ï¼Œè¯·é‡æ–°è¾“å…¥ä»…åŒ…å«æ•°å­—çš„ç­”æ¡ˆã€‚");
          deleteMessage(chatId, message_id);
        }
        return;
      }
    }

    if (text) {
      let cache = CacheService.getScriptCache();

      let editTaskContentStr = cache.get("EDIT_TASK_CONTENT_" + senderId);
      if (editTaskContentStr) {
        let taskId = editTaskContentStr;
        let tasks = getScheduledTasks();
        let taskIndex = tasks.findIndex(t => t.id === taskId);
        if (taskIndex === -1) {
          sendMessage(chatId, "å®šæ—¶æ¶ˆæ¯ä¸å­˜åœ¨");
          cache.remove("EDIT_TASK_CONTENT_" + senderId);
          return;
        }
        let task = tasks[taskIndex];
        task.content = text.trim();
        setScheduledTasks(tasks);
        sendMessage(chatId, `å®šæ—¶æ¶ˆæ¯çš„ content å·²æ›´æ–°ä¸ºï¼š${text.trim()}`);
        cache.remove("EDIT_TASK_CONTENT_" + senderId);
        sendScheduledTasksMenu(chatId);
        return;
      }

      let editTaskDataStr = cache.get("EDIT_TASK_" + senderId);
      if (editTaskDataStr) {
        let editTaskData = JSON.parse(editTaskDataStr);
        let taskId = editTaskData.taskId;
        let field = editTaskData.field;
        let newValue = text.trim();
        let tasks = getScheduledTasks();
        let taskIndex = tasks.findIndex(t => t.id === taskId);
        if (taskIndex === -1) {
          sendMessage(chatId, "å®šæ—¶æ¶ˆæ¯ä¸å­˜åœ¨");
          cache.remove("EDIT_TASK_" + senderId);
          return;
        }
        let task = tasks[taskIndex];
        switch (field) {
          case "chatId":
            task.chatId = newValue;
            break;
          case "time":
            let sendTime = new Date(newValue);
            if (isNaN(sendTime.getTime())) {
              sendMessage(chatId, "æ—¶é—´æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨ YYYY-MM-DD HH:MM:SSï¼Œä¾‹å¦‚ 2023-12-31 23:59:59");
              return;
            }
            task.time = sendTime.getTime();
            break;
          case "type":
            if (!["text", "photo", "video", "audio", "document"].includes(newValue)) {
              sendMessage(chatId, "ç±»å‹é”™è¯¯ï¼Œè¯·ä½¿ç”¨ text, photo, video, audio æˆ– document");
              return;
            }
            task.type = newValue;
            sendMessage(chatId, `è¯·å‘é€æ–°çš„å†…å®¹ï¼ˆå¯¹äº${newValue}æ˜¯${newValue === "text" ? "æ–‡æœ¬" : "åª’ä½“URL"}ï¼‰`);
            cache.put("EDIT_TASK_CONTENT_" + senderId, taskId, 300);
            break;
          case "content":
            task.content = newValue;
            break;
          case "buttons":
            let btnParts = newValue.split(",").map(p => p.trim());
            if (btnParts.length % 2 !== 0) {
              sendMessage(chatId, "æŒ‰é’®æ–‡æœ¬å’ŒURLå¿…é¡»æˆå¯¹å‡ºç°ï¼Œä¾‹å¦‚ï¼šæŒ‰é’®1,https://example.com/1,æŒ‰é’®2,https://example.com/2");
              return;
            }
            task.buttons = [];
            for (let i = 0; i < btnParts.length; i += 2) {
              task.buttons.push({ text: btnParts[i], url: btnParts[i + 1] });
            }
            break;
          case "repeat":
            let repeat = newValue.toLowerCase();
            if (!["none", "hourly", "daily", "weekly", "monthly"].includes(repeat)) {
              sendMessage(chatId, "é‡å¤å‘¨æœŸé”™è¯¯ï¼Œå¯ç”¨å€¼ï¼šnone, hourly, daily, weekly, monthly");
              return;
            }
            task.repeat = repeat;
            break;
          case "caption":
            task.caption = newValue;
            break;
          default:
            sendMessage(chatId, "æœªçŸ¥å­—æ®µ");
            cache.remove("EDIT_TASK_" + senderId);
            return;
        }
        setScheduledTasks(tasks);
        if (field !== "type") {
          sendMessage(chatId, `å®šæ—¶æ¶ˆæ¯çš„ ${field} å·²æ›´æ–°ä¸ºï¼š${newValue}`);
          cache.remove("EDIT_TASK_" + senderId);
          sendScheduledTasksMenu(chatId);
        }
        return;
      }

      let addReplyDataStr = cache.get("ADD_reply_" + senderId);
      if (addReplyDataStr) {
        let addReplyData = JSON.parse(addReplyDataStr);
        let step = addReplyData.step;
        switch (step) {
          case "keyword":
            addReplyData.keyword = text.trim();
            addReplyData.step = "type";
            cache.put("ADD_reply_" + senderId, JSON.stringify(addReplyData), 300);
            sendMessage(chatId, "è¯·å‘é€å›å¤ç±»å‹ï¼ˆtext, photo, video, audio, documentï¼‰ï¼š");
            break;
          case "type":
            let type = text.trim().toLowerCase();
            if (["text", "photo", "video", "audio", "document"].includes(type)) {
              addReplyData.type = type;
              addReplyData.step = "content";
              cache.put("ADD_reply_" + senderId, JSON.stringify(addReplyData), 300);
              sendMessage(chatId, `è¯·å‘é€${type}å†…å®¹ï¼ˆå¯¹äºtextæ˜¯æ–‡æœ¬ï¼Œå¯¹äºå…¶ä»–æ˜¯åª’ä½“URLï¼‰ï¼š`);
            } else sendMessage(chatId, "ç±»å‹é”™è¯¯ï¼Œè¯·ä½¿ç”¨ text, photo, video, audio æˆ– document");
            break;
          case "content":
            addReplyData.content = text.trim();
            if (addReplyData.type !== "text") {
              addReplyData.step = "caption";
              cache.put("ADD_reply_" + senderId, JSON.stringify(addReplyData), 300);
              sendMessage(chatId, "è¯·å‘é€captionï¼ˆå¯é€‰ï¼ŒæŒ‰ Enter è·³è¿‡ï¼‰ï¼š");
            } else {
              addReplyData.step = "url";
              cache.put("ADD_reply_" + senderId, JSON.stringify(addReplyData), 300);
              sendMessage(chatId, "è¯·å‘é€è¶…çº§é“¾æ¥ï¼ˆå¯é€‰ï¼ŒæŒ‰ Enter è·³è¿‡ï¼‰ï¼š");
            }
            break;
          case "caption":
            addReplyData.caption = text.trim();
            addReplyData.step = "url";
            cache.put("ADD_reply_" + senderId, JSON.stringify(addReplyData), 300);
            sendMessage(chatId, "è¯·å‘é€è¶…çº§é“¾æ¥ï¼ˆå¯é€‰ï¼ŒæŒ‰ Enter è·³è¿‡ï¼‰ï¼š");
            break;
          case "url":
            addReplyData.url = text.trim();
            saveReply(addReplyData);
            sendMessage(chatId, `å…³é”®è¯å›å¤ "${addReplyData.keyword}" å·²æ·»åŠ `);
            cache.remove("ADD_reply_" + senderId);
            break;
        }
        return;
      }

      let editWelcomeDataStr = cache.get("EDIT_WELCOME_" + senderId);
      if (editWelcomeDataStr) {
        let editWelcomeData = JSON.parse(editWelcomeDataStr);
        let step = editWelcomeData.step;
        switch (step) {
          case "type":
            let type = text.trim().toLowerCase();
            if (["text", "photo", "video", "audio", "document"].includes(type)) {
              editWelcomeData.type = type;
              editWelcomeData.step = "content";
              cache.put("EDIT_WELCOME_" + senderId, JSON.stringify(editWelcomeData), 300);
              sendMessage(chatId, `è¯·å‘é€${type}å†…å®¹ï¼ˆå¯¹äºtextæ˜¯æ–‡æœ¬ï¼Œå¯¹äºå…¶ä»–æ˜¯åª’ä½“URLï¼‰ï¼š`);
            } else sendMessage(chatId, "ç±»å‹é”™è¯¯ï¼Œè¯·ä½¿ç”¨ text, photo, video, audio æˆ– document");
            break;
          case "content":
            editWelcomeData.content = text.trim();
            if (editWelcomeData.type !== "text") {
              editWelcomeData.step = "caption";
              cache.put("EDIT_WELCOME_" + senderId, JSON.stringify(editWelcomeData), 300);
              sendMessage(chatId, "è¯·å‘é€captionï¼ˆå¯é€‰ï¼ŒæŒ‰ Enter è·³è¿‡ï¼‰ï¼š");
            } else {
              editWelcomeData.step = "buttons";
              cache.put("EDIT_WELCOME_" + senderId, JSON.stringify(editWelcomeData), 300);
              sendMessage(chatId, "è¯·å‘é€æŒ‰é’®ä¿¡æ¯ï¼Œæ ¼å¼ï¼šæ–‡æœ¬1,URL1,æ–‡æœ¬2,URL2,...ï¼ˆå¤šä¸ªæŒ‰é’®ç”¨é€—å·åˆ†éš”ï¼ŒæŒ‰ Enter è·³è¿‡ï¼‰ï¼š");
            }
            break;
          case "caption":
            editWelcomeData.caption = text.trim();
            editWelcomeData.step = "buttons";
            cache.put("EDIT_WELCOME_" + senderId, JSON.stringify(editWelcomeData), 300);
            sendMessage(chatId, "è¯·å‘é€æŒ‰é’®ä¿¡æ¯ï¼Œæ ¼å¼ï¼šæ–‡æœ¬1,URL1,æ–‡æœ¬2,URL2,...ï¼ˆå¤šä¸ªæŒ‰é’®ç”¨é€—å·åˆ†éš”ï¼ŒæŒ‰ Enter è·³è¿‡ï¼‰ï¼š");
            break;
          case "buttons":
            let btnParts = text.trim().split(",").map(p => p.trim());
            if (btnParts.length > 0 && btnParts.length % 2 === 0) {
              editWelcomeData.buttons = [];
              for (let i = 0; i < btnParts.length; i += 2) {
                editWelcomeData.buttons.push({ text: btnParts[i], url: btnParts[i + 1] });
              }
            } else editWelcomeData.buttons = [];
            setWelcomeMessage({
              type: editWelcomeData.type,
              content: editWelcomeData.type === "text" ? editWelcomeData.content : undefined,
              media: editWelcomeData.type !== "text" ? editWelcomeData.content : undefined,
              caption: editWelcomeData.caption || "",
              buttons: editWelcomeData.buttons
            });
            sendMessage(chatId, "æ¬¢è¿æ¶ˆæ¯å·²æ›´æ–°ï¼");
            cache.remove("EDIT_WELCOME_" + senderId);
            break;
        }
        return;
      }

      let setupDataStr = cache.get("TASK_SETUP_" + chatId);
      if (setupDataStr) {
        let setupData = JSON.parse(setupDataStr);
        let step = setupData.step;
        let taskData = setupData.data;
        switch (step) {
          case "chatId": taskData.chatId = text.trim(); sendTaskSetupMessage(chatId, "time", taskData); break;
          case "time":
            let sendTime = new Date(text.trim());
            if (isNaN(sendTime.getTime())) sendMessage(chatId, "æ—¶é—´æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨ YYYY-MM-DD HH:MM:SS");
            else { taskData.time = sendTime.getTime(); sendTaskSetupMessage(chatId, "type", taskData); }
            break;
          case "type":
            if (["text", "photo", "video", "audio", "document"].includes(text.trim().toLowerCase())) {
              taskData.type = text.trim().toLowerCase();
              sendTaskSetupMessage(chatId, "content", taskData);
            } else sendMessage(chatId, "ç±»å‹é”™è¯¯ï¼Œè¯·ä½¿ç”¨ text, photo, video, audio æˆ– document");
            break;
          case "content": taskData.content = text.trim(); sendTaskSetupMessage(chatId, "buttons", taskData); break;
          case "buttons":
            let btnParts = text.split(",").map(p => p.trim());
            if (btnParts.length % 2 !== 0) sendMessage(chatId, "æŒ‰é’®æ–‡æœ¬å’ŒURLå¿…é¡»æˆå¯¹å‡ºç°");
            else {
              taskData.buttons = [];
              for (let i = 0; i < btnParts.length; i += 2) taskData.buttons.push({ text: btnParts[i], url: btnParts[i + 1] });
              sendTaskSetupMessage(chatId, "repeat", taskData);
            }
            break;
          case "repeat":
            let repeat = text.trim().toLowerCase();
            if (["none", "hourly", "daily", "weekly", "monthly"].includes(repeat)) {
              taskData.repeat = repeat;
              if (taskData.type !== "text") sendTaskSetupMessage(chatId, "caption", taskData);
              else {
                taskData.lastMessageId = null; addScheduledTask(taskData); sendMessage(chatId, "å®šæ—¶ä»»åŠ¡å·²æ·»åŠ ã€‚"); cache.remove("TASK_SETUP_" + chatId);
              }
            } else sendMessage(chatId, "é‡å¤å‘¨æœŸé”™è¯¯ï¼Œå¯ç”¨å€¼ï¼šnone, hourly, daily, weekly, monthly");
            break;
          case "caption":
            taskData.caption = text.trim() || ""; taskData.lastMessageId = null; addScheduledTask(taskData);
            sendMessage(chatId, "å®šæ—¶ä»»åŠ¡å·²æ·»åŠ ã€‚"); cache.remove("TASK_SETUP_" + chatId);
            break;
        }
        return;
      }

      if (isCreator(senderId)) {
        if (text.startsWith("/addreply") || text.startsWith("/editreply")) {
          let params = text.substring(text.indexOf(" ") + 1).trim();
          let parts = params.split("|");
          if (parts.length < 3) return sendMessage(chatId, "æ ¼å¼é”™è¯¯ï¼Œæ ¼å¼ï¼š/addreply å…³é”®è¯|ç±»å‹|å†…å®¹[|é“¾æ¥|è¯´æ˜]ï¼Œç±»å‹å¯ä¸º text, photo, video, document");
          let keyword = parts[0].trim();
          let type = parts[1].trim();
          let content = parts[2].trim();
          let replyObj = { type: type };
          if (type === "text") {
            replyObj.content = content;
            replyObj.url = parts.length >= 4 ? parts[3].trim() : "";
          } else if (["photo", "video", "audio", "document"].includes(type)) {
            replyObj.media = content;
            replyObj.caption = parts.length >= 4 ? parts[3].trim() : "";
            replyObj.url = parts.length >= 5 ? parts[4].trim() : "";
          } else return sendMessage(chatId, "æœªçŸ¥çš„ç±»å‹ï¼Œè¯·ä½¿ç”¨ text, photo, video, audio æˆ– document");
          let customReplies = getCustomReplies();
          if (customReplies.hasOwnProperty(keyword) && text.startsWith("/addreply")) return sendMessage(chatId, `å…³é”®è¯ "${keyword}" å·²å­˜åœ¨ï¼Œè¯·ä½¿ç”¨å…¶ä»–å…³é”®è¯æˆ–ä½¿ç”¨ /editreply æ›´æ–°ã€‚`);
          customReplies[keyword] = replyObj;
          setCustomReplies(customReplies);
          Logger.log(`æ·»åŠ /æ›´æ–°å…³é”®è¯å›å¤: ${keyword} -> ${JSON.stringify(replyObj)}`);
          return sendMessage(chatId, `å…³é”®è¯å›å¤ "${keyword}" å·²æ·»åŠ /æ›´æ–°`);
        }
        if (text.startsWith("/delreply")) {
          let keyword = text.substring(9).trim();
          let customReplies = getCustomReplies();
          if (customReplies.hasOwnProperty(keyword)) {
            delete customReplies[keyword];
            setCustomReplies(customReplies);
            Logger.log(`åˆ é™¤å…³é”®è¯å›å¤: ${keyword}`);
            return sendMessage(chatId, `å…³é”®è¯å›å¤ "${keyword}" å·²åˆ é™¤`);
          }
          return sendMessage(chatId, `å…³é”®è¯å›å¤ "${keyword}" ä¸å­˜åœ¨`);
        }
        if (text.startsWith("/delfuzzy")) {
          let params = text.substring(text.indexOf(" ") + 1).trim();
          let fuzzyWords = getFuzzyBannedWords();
          let index = fuzzyWords.indexOf(params);
          if (index !== -1) {
            fuzzyWords.splice(index, 1);
            setFuzzyBannedWords(fuzzyWords);
            Logger.log(`åˆ é™¤è‡ªå®šä¹‰æ¨¡ç³Šè¿ç¦è¯ï¼š${params}`);
            return sendMessage(chatId, `è‡ªå®šä¹‰æ¨¡ç³Šè¿ç¦è¯ "${params}" å·²åˆ é™¤`);
          }
          return sendMessage(chatId, `è‡ªå®šä¹‰æ¨¡ç³Šè¿ç¦è¯ "${params}" ä¸å­˜åœ¨`);
        }
      } else if (text && (text.startsWith("/addreply") || text.startsWith("/editreply") || text.startsWith("/delreply") || text.startsWith("/delfuzzy"))) {
        sendMessage(chatId, "âŒ åªæœ‰æœºå™¨äººåˆ›å»ºè€…å¯ä»¥ä½¿ç”¨è¯¥å‘½ä»¤");
        return;
      }

      if (isSenderAdmin) {
        if (text.startsWith("/clearwarnings")) {
          if (message.reply_to_message && message.reply_to_message.from) {
            let targetUser = message.reply_to_message.from;
            deleteWarningCount(chatId, targetUser.id);
            return sendMessage(chatId, `å·²æ¸…é™¤ç”¨æˆ· ${targetUser.id} çš„è­¦å‘Šè®°å½•`);
          }
          let parts = text.split(" ");
          if (parts.length < 2) return sendMessage(chatId, "è¯·å›å¤è¦æ¸…é™¤è­¦å‘Šçš„ç”¨æˆ·æ¶ˆæ¯ï¼Œæˆ–è€…ä½¿ç”¨æ ¼å¼ï¼š/clearwarnings ç”¨æˆ·ID");
          let targetUserId = parts[1].trim();
          deleteWarningCount(chatId, targetUserId);
          return sendMessage(chatId, `å·²æ¸…é™¤ç”¨æˆ· ${targetUserId} çš„è­¦å‘Šè®°å½•`);
        }
        if (text.startsWith("/stats")) {
          let allProps = PropertiesService.getScriptProperties().getProperties();
          let statsText = "å½“å‰è­¦å‘Šç»Ÿè®¡ï¼š\n";
          for (let key in allProps) {
            if (key.indexOf("warn_" + chatId + "_") === 0) {
              let parts = key.split("_");
              let userId = parts[2];
              let count = allProps[key];
              statsText += `ç”¨æˆ· ${userId} è­¦å‘Šæ¬¡æ•°: ${count}\n`;
            }
          }
          if (statsText === "å½“å‰è­¦å‘Šç»Ÿè®¡ï¼š\n") statsText += "æ— è­¦å‘Šè®°å½•ã€‚";
          return sendMessage(chatId, statsText);
        }
        if (text.startsWith("/setpindelete")) {
          let parts = text.split(" ");
          if (parts.length < 2) return sendMessage(chatId, "æ ¼å¼é”™è¯¯ï¼Œä½¿ç”¨ï¼š/setpindelete on/off [é—´éš”åˆ†é’Ÿæ•°]");
          let state = parts[1].toLowerCase();
          if (state === "on") {
            let interval = parts.length > 2 ? parseInt(parts[2], 10) : 60;
            if (isNaN(interval) || interval < 1) interval = 60;
            setPinAutoDeleteEnabled(true);
            setPinAutoDeleteInterval(interval);
            setupPinAutoDeleteTrigger();
            return sendMessage(chatId, `ç½®é¡¶æ¶ˆæ¯è‡ªåŠ¨åˆ é™¤å·²å¯ç”¨ï¼Œæ¯ ${interval} åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡ã€‚`);
          }
          else if (state === "off") {
            setPinAutoDeleteEnabled(false);
            deleteTriggers("deletePinnedMessages");
            return sendMessage(chatId, "ç½®é¡¶æ¶ˆæ¯è‡ªåŠ¨åˆ é™¤å·²å…³é—­ã€‚");
          }
          else return sendMessage(chatId, "æ— æ•ˆå‚æ•°ï¼Œä½¿ç”¨ï¼š/setpindelete on/off [é—´éš”åˆ†é’Ÿæ•°]");
        }
      }

      const cacheFuzzy = CacheService.getScriptCache();
      const cachedChatId = cacheFuzzy.get("TEMP_FUZZY_" + senderId);
      if (cachedChatId !== null) {
        if (chatId > 0 || cachedChatId === chatId.toString()) {
          let words = text.split(/[,\uFF0C]/).map(w => w.trim());
          let fuzzyWords = getFuzzyBannedWords();
          let added = [];
          words.forEach(word => {
            if (word && fuzzyWords.indexOf(word) === -1) {
              fuzzyWords.push(word);
              added.push(word);
            }
          });
          if (added.length > 0) {
            setFuzzyBannedWords(fuzzyWords);
            Logger.log(`æˆåŠŸæ·»åŠ æ¨¡ç³Šè¿ç¦è¯ï¼š${added.join(", ")}`);
            sendMessage(chatId, `è‡ªå®šä¹‰æ¨¡ç³Šè¿ç¦è¯ "${added.join(", ")}" å·²æ·»åŠ ã€‚`);
          } else sendMessage(chatId, "æ‰€æœ‰è¿ç¦è¯å‡å·²å­˜åœ¨ï¼Œæ— æ–°è¯æ·»åŠ ã€‚");
          cacheFuzzy.remove("TEMP_FUZZY_" + senderId);
          return;
        }
      }
    }

    if (message.new_chat_members) {
      const newMembers = message.new_chat_members;
      const spamPhrases = getSpamPhrases();
      const isMathVerificationEnabled = getMathVerificationEnabled();
      const joinTime = message.date;
      let membersToWelcome = [];
      newMembers.forEach(function(member) {
        const fullName = (member.first_name || "") + " " + (member.last_name || "").trim();
        if (containsSpamPhrase(fullName, spamPhrases)) {
          kickUser(chatId, member.id);
          sendMessage(chatId, `ç”¨æˆ· ${member.first_name} (ID: ${member.id}) å› åå­—åŒ…å«æ•æ„Ÿè¯è¢«è¸¢å‡ºã€‚`);
        } else {
          if (member.id === BOT_ID) {
            const inviterId = message.from.id;
            if (isCreator(inviterId)) {
              sendMessage(chatId, "æœºå™¨äººå·²ç”±ç¾¤ç»„åˆ›å»ºè€…æ‹‰å…¥ï¼Œæ¬¢è¿ä½¿ç”¨ï¼");
            } else {
              sendMessage(chatId, "åªæœ‰ç¾¤ç»„åˆ›å»ºè€…æ‰èƒ½å°†æœºå™¨äººæ‹‰å…¥ç¾¤ç»„ï¼Œæœºå™¨äººå°†è‡ªåŠ¨é€€å‡ºã€‚");
              sendRequest("leaveChat", { chat_id: chatId });
              return;
            }
          } else {
            if (isMathVerificationEnabled) {
              let a = Math.floor(Math.random() * 10) + 1;
              let b = Math.floor(Math.random() * 10) + 1;
              let answer = (a + b).toString();
              setMathVerifyAnswer(chatId, member.id, answer);
              let verificationMessage = sendMessage(chatId, `æ¬¢è¿ ${member.first_name}ï¼è¯·åœ¨1åˆ†é’Ÿå†…å›å¤ç­”æ¡ˆï¼š${a} + ${b} = ? (ä»…è¾“å…¥æ•°å­—)`);
              let verificationMessageId = null;
              if (verificationMessage && verificationMessage.ok && verificationMessage.result && verificationMessage.result.message_id) {
                verificationMessageId = verificationMessage.result.message_id;
              } else {
                Logger.log(`å‘é€éªŒè¯æ¶ˆæ¯å¤±è´¥ç»™ç”¨æˆ· ${member.id} åœ¨ç¾¤ ${chatId}`);
              }
              setJoinData(chatId, member.id, joinTime, member.first_name, verificationMessageId);
              setVerifiedStatus(chatId, member.id, "false");
            } else if (getWelcomeEnabled()) {
              membersToWelcome.push(member);
            }
          }
        }
      });
      if (getWelcomeEnabled() && membersToWelcome.length > 0) sendCustomWelcome(chatId, membersToWelcome);
      deleteMessage(chatId, message_id);
      return;
    }

    if (message.left_chat_member) {
      const name = message.left_chat_member.first_name;
      sendAutoDeleteMessage(chatId, `ç”¨æˆ· ${name} ç¦»å¼€äº†ç¾¤èŠ`, getEventAutoDeleteDuration());
      deleteMessage(chatId, message_id);
      return;
    }
    if (message.new_chat_title) {
      const newTitle = message.new_chat_title;
      sendAutoDeleteMessage(chatId, `ç¾¤èŠåç§°å·²æ›´æ–°ä¸º: ${newTitle}`, getEventAutoDeleteDuration());
      deleteMessage(chatId, message_id);
      return;
    }

    if (getFilterEnabled() && (!isSenderAdmin || !getAdminExempt())) {
      if (message.forward_from_chat && message.forward_from_chat.type === "channel") {
        Logger.log("æ£€æµ‹åˆ°ä»é¢‘é“è½¬å‘çš„æ¶ˆæ¯");
        return handleViolation(chatId, senderId, message_id);
      }
      if (getForwardFilterEnabled() && message.forward_date) {
        let fwdContent = text || message.caption || "";
        if (fwdContent && isSpam(fwdContent)) {
          Logger.log("æ£€æµ‹åˆ°è½¬å‘æ¶ˆæ¯å†…å®¹è¿è§„");
          return handleViolation(chatId, senderId, message_id);
        }
      }
      if (text) {
        if (USER_LAST_MESSAGE[chatId] === text) return;
        USER_LAST_MESSAGE[chatId] = text;
        if (isSpam(text)) {
          Logger.log("æ£€æµ‹åˆ°æ–‡æœ¬è¿è§„");
          return handleViolation(chatId, senderId, message_id);
        }
      }
      if (message.photo && getPornMediaFilterEnabled()) {
        let photoArray = message.photo;
        let largestPhoto = photoArray[photoArray.length - 1];
        let file_id = largestPhoto.file_id;
        if (analyzePhotoSafeSearch(file_id)) {
          Logger.log("æ£€æµ‹åˆ°è‰²æƒ…åª’ä½“è¿è§„");
          return handleViolation(chatId, senderId, message_id);
        }
      }
      if (message.video || message.animation) {
        let caption = message.caption;
        if (caption && isSpam(caption)) {
          Logger.log("æ£€æµ‹åˆ°è§†é¢‘/åŠ¨ç”»è¿è§„");
          return handleViolation(chatId, senderId, message_id);
        }
      }
      if (message.document) {
        let fileName = message.document.file_name || "";
        if (/\.apk$/i.test(fileName)) {
          Logger.log("æ£€æµ‹åˆ° APK æ–‡ä»¶è¿è§„");
          return handleViolation(chatId, senderId, message_id);
        }
      }
      if (message.sticker) {
        Logger.log("æ£€æµ‹åˆ°è´´çº¸è¿è§„");
        return handleViolation(chatId, senderId, message_id);
      }
      if (message.custom_emoji) {
        Logger.log("æ£€æµ‹åˆ°è‡ªå®šä¹‰è¡¨æƒ…è¿è§„");
        return handleViolation(chatId, senderId, message_id);
      }
    }

    if (text) {
      const customReplies = getCustomReplies();
      if (customReplies[text]) {
        Logger.log("åŒ¹é…åˆ°è‡ªå®šä¹‰å›å¤: " + text);
        return sendCustomReply(chatId, customReplies[text]);
      }
    }
  } catch (error) {
    Logger.log("âŒ å¤„ç†æ¶ˆæ¯å‡ºé”™: " + error.toString());
  }
}

// ========== ä¿å­˜å…³é”®è¯å›å¤ ==========
function saveReply(data) {
  let customReplies = getCustomReplies();
  let replyObj = { type: data.type };
  if (data.type === "text") {
    replyObj.content = data.content;
    replyObj.url = data.url || "";
  } else {
    replyObj.media = data.content;
    if (data.caption) replyObj.caption = data.caption;
    replyObj.url = data.url || "";
  }
  customReplies[data.keyword] = replyObj;
  setCustomReplies(customReplies);
  Logger.log(`æ·»åŠ å…³é”®è¯å›å¤: ${data.keyword} -> ${JSON.stringify(replyObj)}`);
}

// ========== å¤„ç½šå‡½æ•° ==========
function banUser(chatId, userId) {
  if (userId === BOT_ID) return false;
  let result = sendRequest("restrictChatMember", {
    chat_id: chatId,
    user_id: userId,
    permissions: { can_send_messages: false }
  });
  return result && result.ok;
}

function handleChatMemberUpdate(chatMemberUpdate) {
  const chatId = chatMemberUpdate.chat.id;
  const oldMember = chatMemberUpdate.old_chat_member;
  const newMember = chatMemberUpdate.new_chat_member;
  if (oldMember.user.first_name !== newMember.user.first_name || oldMember.user.last_name !== newMember.user.last_name) {
    const userId = newMember.user.id;
    const oldName = oldMember.user.first_name + (oldMember.user.last_name ? " " + oldMember.user.last_name : "");
    const newName = newMember.user.first_name + (newMember.user.last_name ? " " + newMember.user.last_name : "");
    Logger.log(`æ£€æµ‹åˆ°ç”¨æˆ·æ›´åï¼š${oldName} -> ${newName}`);
    const reminderText = `ç”¨æˆ· ${oldName} æ›´åä¸º ${newName}ï¼Œè¯·è°¨é˜²å†’å……è¯¥ç”¨æˆ·æè¯ˆéª—ï¼`;
    const result = sendMessage(chatId, reminderText);
    if (result && result.ok && result.result && result.result.message_id) {
      pinChatMessage(chatId, result.result.message_id);
      Logger.log(`æˆåŠŸç½®é¡¶æ¶ˆæ¯ ${result.result.message_id} åœ¨ç¾¤ ${chatId}`);
    } else {
      Logger.log(`ç½®é¡¶æ›´åæç¤ºæ¶ˆæ¯å¤±è´¥åœ¨ç¾¤ ${chatId}`);
    }
  }
}

function pinChatMessage(chatId, messageId) {
  let result = sendRequest("pinChatMessage", { chat_id: chatId, message_id: messageId, disable_notification: true });
  if (result && result.ok) Logger.log(`æˆåŠŸç½®é¡¶æ¶ˆæ¯ ${messageId} åœ¨ç¾¤ ${chatId}`);
  else Logger.log(`ç½®é¡¶æ¶ˆæ¯ ${messageId} åœ¨ç¾¤ ${chatId} å¤±è´¥`);
}

// ========== å¸®åŠ©è¯´æ˜æ¶ˆæ¯ ==========
function sendHelpMessage(chatId) {
  const helpText =
    "ã€ä½¿ç”¨è¯´æ˜ã€‘\n\n" +
    "ã€åŸºæœ¬å‘½ä»¤ã€‘\n" +
    "â€¢ /help - æ˜¾ç¤ºæœ¬å¸®åŠ©ä¿¡æ¯\n" +
    "â€¢ /start - æ˜¾ç¤ºä¸»èœå•\n" +
    "â€¢ /settings - æ˜¾ç¤ºè®¾ç½®é¢æ¿ï¼ˆä»…åˆ›å»ºè€…ï¼‰\n" +
    "â€¢ /ban - æ°¸ä¹…ç¦è¨€æŒ‡å®šç”¨æˆ·ï¼ˆä»…ç®¡ç†å‘˜ï¼Œå¯é€šè¿‡å›å¤æ¶ˆæ¯æˆ–æŒ‡å®šç”¨æˆ·IDï¼‰\n" +
    "â€¢ /stats - æŸ¥çœ‹å½“å‰ç¾¤å†…è¿è§„è­¦å‘Šç»Ÿè®¡ï¼ˆä»…ç®¡ç†å‘˜ï¼‰\n" +
    "â€¢ /clearwarnings - æ¸…é™¤æŒ‡å®šç”¨æˆ·çš„è­¦å‘Šè®°å½•ï¼ˆä»…ç®¡ç†å‘˜ï¼Œå¯é€šè¿‡å›å¤æ¶ˆæ¯æˆ–æŒ‡å®šç”¨æˆ·IDï¼‰\n" +
    "â€¢ /setpindelete on/off [é—´éš”åˆ†é’Ÿæ•°] - è®¾ç½®ç½®é¡¶æ¶ˆæ¯è‡ªåŠ¨åˆ é™¤ï¼ˆä»…ç®¡ç†å‘˜ï¼‰\n" +
    "â€¢ /setnightmode on å¼€å§‹æ—¶é—´ ç»“æŸæ—¶é—´ æ—¶åŒºåç§» æˆ– /setnightmode off - è®¾ç½®å¤œé—´æ¨¡å¼ï¼ˆä»…åˆ›å»ºè€…ï¼‰\n" +
    "    - ç¤ºä¾‹ï¼š/setnightmode on 22:00 07:00 UTC+8\n" +
    "â€¢ /addscheduledmsg ç¾¤ID|æ—¶é—´|ç±»å‹|å†…å®¹|æŒ‰é’®æ–‡æœ¬1,æŒ‰é’®æ–‡æœ¬2|æŒ‰é’®URL1,æŒ‰é’®URL2|é‡å¤å‘¨æœŸ[|caption] - æ·»åŠ å®šæ—¶æ¶ˆæ¯ï¼ˆä»…åˆ›å»ºè€…ï¼‰\n" +
    "    - ç¤ºä¾‹ï¼š/addscheduledmsg -123456789|2023-12-31 23:59:59|text|å®šæ—¶æ¶ˆæ¯|btn1,btn2|https://example.com/1,https://example.com/2|hourly\n" +
    "â€¢ /myid - æŸ¥è¯¢æ‚¨çš„ç”¨æˆ·ID\n" +
    "ã€è‡ªå®šä¹‰å›å¤ç®¡ç†ã€‘\n" +
    "â€¢ /addreply å…³é”®è¯|ç±»å‹|å†…å®¹[|é“¾æ¥|è¯´æ˜]\n" +
    "    - æ·»åŠ æˆ–æ›´æ–°è‡ªå®šä¹‰å›å¤ï¼ˆä»…åˆ›å»ºè€…ï¼‰\n" +
    "    - ç¤ºä¾‹ï¼š/addreply æŒ‰é’®7|text|è¿™æ˜¯æ–°å›å¤|https://example.com\n" +
    "    - ç±»å‹å¯ä¸º text, photo, video, audio, documentï¼ˆdocument å¯ç”¨äºå‘é€ä»»æ„æ–‡ä»¶ï¼Œå¦‚ EXE, APK, ZIP ç­‰ï¼‰\n" +
    "â€¢ /delreply å…³é”®è¯ - åˆ é™¤æŒ‡å®šçš„è‡ªå®šä¹‰å›å¤ï¼ˆä»…åˆ›å»ºè€…ï¼‰\n" +
    "â€¢ /delfuzzy è¿ç¦è¯ - åˆ é™¤æŒ‡å®šçš„æ¨¡ç³Šè¿ç¦è¯ï¼ˆä»…åˆ›å»ºè€…ï¼‰\n" +
    "â€¢ è®¾ç½®é¢æ¿ä¸­ã€å…³é”®è¯å›å¤ã€‘æŒ‰é’® - æŸ¥çœ‹åˆ—è¡¨ï¼Œæˆ–ç‚¹å‡»ã€æ·»åŠ å…³é”®è¯å›å¤ã€‘æŒ‰é’®è¿›è¡Œå¼•å¯¼å¼è®¾ç½®\n" +
    "ã€æ¨¡ç³Šè¿ç¦è¯ç®¡ç†ã€‘\n" +
    "â€¢ ç‚¹å‡»è®¾ç½®é¢æ¿ä¸­çš„ã€æ¨¡ç³Šè¿ç¦è¯ç®¡ç†ã€‘æŒ‰é’®æŸ¥çœ‹ã€æ·»åŠ æˆ–åˆ é™¤\n" +
    "ã€æ¬¢è¿æ¶ˆæ¯è®¾ç½®ã€‘\n" +
    "â€¢ ç‚¹å‡»ã€è®¾ç½®æ¬¢è¿æ¶ˆæ¯ã€‘æŒ‰é’®ä¿®æ”¹æ¬¢è¿æ¶ˆæ¯ï¼Œé€šè¿‡å¼•å¯¼å¼è®¾ç½®å®Œæˆï¼Œæ”¯æŒå¤šä¸ªè¶…çº§é“¾æ¥æŒ‰é’®ï¼ˆå¯é€‰ï¼‰\n" +
    "ã€åƒåœ¾åå­—å±è”½ã€‘\n" +
    "â€¢ /addspam å±è”½è¯ - æ·»åŠ åƒåœ¾çŸ­è¯­åˆ°å±è”½åˆ—è¡¨ï¼ˆä»…åˆ›å»ºè€…ï¼‰\n" +
    "â€¢ /delspam å±è”½è¯ - ä»å±è”½åˆ—è¡¨ä¸­åˆ é™¤åƒåœ¾çŸ­è¯­ï¼ˆä»…åˆ›å»ºè€…ï¼‰\n" +
    "â€¢ /listspam - æŸ¥çœ‹æ‰€æœ‰å·²æ·»åŠ çš„åƒåœ¾çŸ­è¯­ï¼ˆä»…åˆ›å»ºè€…ï¼‰\n" +
    "    - æ–°ç”¨æˆ·åå­—è‹¥åŒ…å«å±è”½åˆ—è¡¨ä¸­çš„çŸ­è¯­ï¼Œå°†è¢«è‡ªåŠ¨è¸¢å‡º\n" +
    "ã€è¿è§„æ£€æµ‹è¯´æ˜ã€‘\n" +
    "â€¢ æ–°ç”¨æˆ·ï¼ˆåŒ…æ‹¬ç®¡ç†å‘˜ï¼‰éœ€åœ¨1åˆ†é’Ÿå†…å›ç­”ç®€å•æ•°å­¦é—®é¢˜è¿›è¡ŒéªŒè¯ï¼Œå¦åˆ™éªŒè¯æ¶ˆæ¯å°†è¢«åˆ é™¤å¹¶æ°¸ä¹…ç¦è¨€\n" +
    "â€¢ éªŒè¯æˆåŠŸåï¼ŒéªŒè¯æ¶ˆæ¯å’Œç”¨æˆ·å›ç­”å°†è¢«åˆ é™¤\n" +
    "â€¢ æœºå™¨äººä¼šè‡ªåŠ¨æ‹¦æˆªæ‰€æœ‰ä»é¢‘é“è½¬å‘çš„æ¶ˆæ¯\n" +
    "â€¢ æ£€æµ‹æ¶ˆæ¯ä¸­çš„å¹¿å‘Šã€é“¾æ¥ã€è‰²æƒ…å†…å®¹ã€æ¨¡ç³Šè¿ç¦è¯ä»¥åŠéå®˜æ–¹è¡¨æƒ…ç¬¦å·ï¼ˆåŒ…æ‹¬è´´çº¸å’Œè‡ªå®šä¹‰è¡¨æƒ…ï¼‰\n" +
    "â€¢ è¿è§„æ—¶åˆ é™¤æ¶ˆæ¯å¹¶è­¦å‘Šï¼Œç´¯è®¡è­¦å‘Šè¾¾åˆ°è®¾å®šæ¬¡æ•°åæ°¸ä¹…ç¦è¨€ç”¨æˆ·\n" +
    "â€¢ ç®¡ç†å‘˜å¯é€šè¿‡è®¾ç½®é¢æ¿å¯ç”¨è±å…ï¼Œè±å…åç®¡ç†å‘˜å‘é€çš„è´´çº¸å’Œè‡ªå®šä¹‰è¡¨æƒ…ä¸è§†ä¸ºè¿è§„\n" +
    "ã€æ–°åŠŸèƒ½ã€‘\n" +
    "â€¢ **æ¬¢è¿æ¶ˆæ¯æŒ‰é’®**ï¼šæ”¯æŒæ‰€æœ‰ç±»å‹æ¶ˆæ¯æ·»åŠ å¤šä¸ªè¶…çº§é“¾æ¥æŒ‰é’®ï¼Œå¯è·³è¿‡è®¾ç½®\n" +
    "â€¢ **é˜²åˆ·å±**ï¼š1åˆ†é’Ÿå†…å‘é€è¶…è¿‡5æ¡æ¶ˆæ¯ï¼Œåˆ é™¤è¯¥ç”¨æˆ·æ‰€æœ‰æ¶ˆæ¯å¹¶æ°¸ä¹…ç¦è¨€\n" +
    "â€¢ **å®šæ—¶æ¶ˆæ¯**ï¼šæ”¯æŒæœ€å¤š20æ¡å®šæ—¶æ¶ˆæ¯ï¼Œå¯è®¾ç½®å¤šä¸ªæŒ‰é’®å’Œcaptionï¼Œç±»å‹æ”¯æŒ text, photo, video, audio, documentï¼Œé‡å¤å‘¨æœŸæ”¯æŒ none, hourly, daily, weekly, monthly\n" +
    "â€¢ **ç½®é¡¶æ¶ˆæ¯è‡ªåŠ¨åˆ é™¤**ï¼šé€šè¿‡ /setpindelete å‘½ä»¤è®¾ç½®å®šæ—¶åˆ é™¤ç¾¤ç½®é¡¶æ¶ˆæ¯\n" +
    "â€¢ **å¤œé—´æ¨¡å¼**ï¼šé€šè¿‡ /setnightmode å‘½ä»¤è®¾ç½®å¤œé—´æ—¶é—´æ®µï¼Œè‡ªåŠ¨åˆ é™¤éç®¡ç†å‘˜æ¶ˆæ¯\n" +
    "â€¢ **åƒåœ¾åå­—å±è”½**ï¼šè‡ªåŠ¨æ£€æµ‹æ–°ç”¨æˆ·åå­—ï¼Œå±è”½åŒ…å«åƒåœ¾çŸ­è¯­çš„ç”¨æˆ·å…¥ç¾¤\n" +
    "â€¢ **åˆ é™¤å·²é”€å·ç”¨æˆ·**ï¼šå¯ç”¨åæ£€æµ‹å¹¶ç§»é™¤ç®¡ç†å‘˜ä¸­çš„å·²é”€å·ç”¨æˆ·ï¼ˆæ³¨ï¼šå›  API é™åˆ¶ï¼Œä»…é™ç®¡ç†å‘˜ï¼Œå»ºè®®æ‰‹åŠ¨æ£€æŸ¥æˆ–é€šè¿‡ç”¨æˆ·äº¤äº’è§¦å‘ï¼‰\n" +
    "â€¢ **æ•°å­¦éªŒè¯**ï¼šå¯¹æ‰€æœ‰æ–°ç”¨æˆ·ï¼ˆåŒ…æ‹¬ç®¡ç†å‘˜ï¼‰å¼ºåˆ¶æ‰§è¡Œï¼Œ1åˆ†é’Ÿå†…æœªé€šè¿‡å°†è¢«æ°¸ä¹…ç¦è¨€ï¼Œæç¤ºæ¶ˆæ¯10ç§’åè‡ªåŠ¨åˆ é™¤\n" +
    "â€¢ **æœºå™¨äººæ‹‰å…¥é™åˆ¶**ï¼šåªæœ‰ç¾¤ç»„åˆ›å»ºè€…æ‰èƒ½å°†æœºå™¨äººæ‹‰å…¥ç¾¤ç»„ï¼Œå¦åˆ™æœºå™¨äººè‡ªåŠ¨é€€å‡º";
  sendMessage(chatId, helpText);
}

// ========== è‡ªå®šä¹‰å›å¤å¤„ç† ==========
function sendCustomReply(chatId, reply) {
  let options = {};
  if (reply.url) options.reply_markup = { inline_keyboard: [[{ text: "è®¿é—®é“¾æ¥", url: reply.url }]] };
  let autoDuration = getReplyAutoDeleteDuration();
  let result;

  switch (reply.type) {
    case "text":
      if (autoDuration > 0) return sendAutoDeleteMessage(chatId, reply.content, autoDuration, options);
      return sendMessage(chatId, reply.content, options);
    case "photo":
      result = sendPhoto(chatId, reply.media, { caption: reply.caption, ...options });
      if (autoDuration > 0 && result && result.ok && result.result && result.result.message_id) {
        scheduleMessageDeletion(chatId, result.result.message_id, autoDuration);
      }
      return result;
    case "video":
      result = sendVideo(chatId, reply.media, { caption: reply.caption, ...options });
      if (autoDuration > 0 && result && result.ok && result.result && result.result.message_id) {
        scheduleMessageDeletion(chatId, result.result.message_id, autoDuration);
      }
      return result;
    case "audio":
      result = sendAudio(chatId, reply.media, { caption: reply.caption, ...options });
      if (autoDuration > 0 && result && result.ok && result.result && result.result.message_id) {
        scheduleMessageDeletion(chatId, result.result.message_id, autoDuration);
      }
      return result;
    case "document":
      // æ”¯æŒå‘é€ä»»æ„æ–‡ä»¶ç±»å‹ï¼ˆå¦‚ EXE, APK, ZIP ç­‰ï¼‰ï¼Œåªéœ€æä¾›æ­£ç¡®çš„ URL
      result = sendDocument(chatId, reply.media, { caption: reply.caption, ...options });
      if (autoDuration > 0 && result && result.ok && result.result && result.result.message_id) {
        scheduleMessageDeletion(chatId, result.result.message_id, autoDuration);
      }
      return result;
    default:
      return sendMessage(chatId, "æœªçŸ¥çš„å›å¤ç±»å‹");
  }
}

// ========== æ¬¢è¿æ¶ˆæ¯å‘é€ ==========
function sendCustomWelcome(chatId, newMembers) {
  if (!getWelcomeEnabled()) return;
  let welcome = getWelcomeMessage();
  let names = newMembers.map(u => u.first_name).join(", ");
  let options = {};
  if (welcome.buttons && welcome.buttons.length > 0) {
    options.reply_markup = {
      inline_keyboard: welcome.buttons.map(btn => [{ text: btn.text, url: btn.url }])
    };
  }
  let autoDuration = getWelcomeAutoDeleteDuration();
  let result;

  if (welcome.type === "text") {
    let textToSend = welcome.content.replace("{names}", names);
    if (autoDuration > 0) sendAutoDeleteMessage(chatId, textToSend, autoDuration, options);
    else sendMessage(chatId, textToSend, options);
  } else if (welcome.type === "photo") {
    options.caption = welcome.caption ? welcome.caption.replace("{names}", names) : "";
    result = sendPhoto(chatId, welcome.media, { ...options });
    if (autoDuration > 0 && result && result.ok && result.result && result.result.message_id) {
      scheduleMessageDeletion(chatId, result.result.message_id, autoDuration);
    }
  } else if (welcome.type === "video") {
    options.caption = welcome.caption ? welcome.caption.replace("{names}", names) : "";
    result = sendVideo(chatId, welcome.media, { ...options });
    if (autoDuration > 0 && result && result.ok && result.result && result.result.message_id) {
      scheduleMessageDeletion(chatId, result.result.message_id, autoDuration);
    }
  } else if (welcome.type === "audio") {
    options.caption = welcome.caption ? welcome.caption.replace("{names}", names) : "";
    result = sendAudio(chatId, welcome.media, { ...options });
    if (autoDuration > 0 && result && result.ok && result.result && result.result.message_id) {
      scheduleMessageDeletion(chatId, result.result.message_id, autoDuration);
    }
  } else if (welcome.type === "document") {
    options.caption = welcome.caption ? welcome.caption.replace("{names}", names) : "";
    result = sendDocument(chatId, welcome.media, { ...options });
    if (autoDuration > 0 && result && result.ok && result.result && result.result.message_id) {
      scheduleMessageDeletion(chatId, result.result.message_id, autoDuration);
    }
  }
}

// ========== è¿è§„æ£€æµ‹åŠå¤„ç† ==========
function isSpam(text) {
  const spamRegex = new RegExp(`\\b(${SPAM_KEYWORDS.join("|")})\\b`, "i");
  const pornRegex = new RegExp(`\\b(${PORN_KEYWORDS.join("|")})\\b`, "i");
  if (spamRegex.test(text) || pornRegex.test(text) || LINK_PATTERN.test(text)) {
    Logger.log("å…³é”®è¯æˆ–é“¾æ¥åŒ¹é…: " + text);
    return true;
  }
  if (getFuzzyMatchEnabled()) {
    const bannedWords = getFuzzyBannedWords();
    Logger.log(`æ£€æŸ¥æ¨¡ç³ŠåŒ¹é…: æ–‡æœ¬="${text}", è¿ç¦è¯=${JSON.stringify(bannedWords)}, é˜ˆå€¼=${FUZZY_THRESHOLD}`);
    if (fuzzyContains(text, bannedWords, FUZZY_THRESHOLD)) {
      Logger.log("æ¨¡ç³ŠåŒ¹é…åˆ°è¿ç¦è¯: " + text);
      return true;
    } else Logger.log("æœªåŒ¹é…åˆ°æ¨¡ç³Šè¿ç¦è¯: " + text);
  }
  return false;
}

function handleViolation(chatId, userId, messageId) {
  if (!deleteMessage(chatId, messageId)) Logger.log(`åˆ é™¤æ¶ˆæ¯ ${messageId} å¤±è´¥`);
  else warnUser(chatId, userId);
}

function deleteMessage(chatId, messageId) {
  let result = sendRequest("deleteMessage", { chat_id: chatId, message_id: messageId });
  Logger.log(`deleteMessage ${chatId}/${messageId}: ${JSON.stringify(result)}`);
  return result && result.ok;
}

function sendAutoDeleteMessage(chatId, text, autoDeleteSeconds, options = {}) {
  const result = sendMessage(chatId, text, options);
  if (result && result.ok && result.result && result.result.message_id && autoDeleteSeconds > 0) {
    scheduleMessageDeletion(chatId, result.result.message_id, autoDeleteSeconds);
  }
}

function scheduleMessageDeletion(chatId, messageId, deleteAfterSeconds) {
  const deleteTime = new Date().getTime() + deleteAfterSeconds * 1000;
  const key = `DELETE_${chatId}_${messageId}`;
  PropertiesService.getScriptProperties().setProperty(key, deleteTime.toString());
}

function checkAndDeleteMessages() {
  const props = PropertiesService.getScriptProperties();
  const now = new Date().getTime();
  const allProps = props.getProperties();
  const keysToDelete = [];
  for (let key in allProps) {
    if (key.startsWith("DELETE_")) {
      const deleteTime = parseInt(allProps[key], 10);
      if (now >= deleteTime) {
        const parts = key.split("_");
        const chatId = parts[1];
        const messageId = parts[2];
        deleteMessage(chatId, messageId);
        keysToDelete.push(key);
      }
    }
  }
  keysToDelete.forEach(key => props.deleteProperty(key));
}

function setupDeletionTrigger() {
  deleteTriggers("checkAndDeleteMessages");
  try {
    ScriptApp.newTrigger("checkAndDeleteMessages")
      .timeBased()
      .everyMinutes(1)
      .create();
    Logger.log("æ¶ˆæ¯è‡ªåŠ¨åˆ é™¤è§¦å‘å™¨å·²è®¾ç½®ä¸ºæ¯åˆ†é’Ÿè¿è¡Œ");
  } catch (err) {
    Logger.log(`è®¾ç½®æ¶ˆæ¯è‡ªåŠ¨åˆ é™¤è§¦å‘å™¨å¤±è´¥: ${err.toString()}`);
  }
}

function warnUser(chatId, userId) {
  let count = getWarningCount(chatId, userId);
  count++;
  setWarningCount(chatId, userId, count);
  const autoDel = getPunishmentAutoDeleteDuration();
  if (count >= getWarningLimit()) {
    if (autoDel > 0) sendAutoDeleteMessage(chatId, `âš ï¸ ç”¨æˆ· ${userId} å·²è¢«æ°¸ä¹…ç¦è¨€ï¼`, autoDel);
    else sendMessage(chatId, `âš ï¸ ç”¨æˆ· ${userId} å·²è¢«æ°¸ä¹…ç¦è¨€ï¼`);
    banUser(chatId, userId);
    deleteWarningCount(chatId, userId);
  } else {
    if (autoDel > 0) sendAutoDeleteMessage(chatId, `âš ï¸ è­¦å‘Š ${count}/${getWarningLimit()}ï¼šè¯·å‹¿å‘é€è¿è§„å†…å®¹ï¼`, autoDel);
    else sendMessage(chatId, `âš ï¸ è­¦å‘Š ${count}/${getWarningLimit()}ï¼šè¯·å‹¿å‘é€è¿è§„å†…å®¹ï¼`);
  }
}

// ========== æ¨¡ç³ŠåŒ¹é…å·¥å…·å‡½æ•° ==========
function levenshteinDistance(a, b) {
  const m = a.length, n = b.length;
  const dp = [];
  for (let i = 0; i <= m; i++) dp[i] = [i];
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (a.charAt(i - 1) === b.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];
      else dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, dp[i][j - 1] + 1, dp[i - 1][j] + 1);
    }
  }
  return dp[m][n];
}

function fuzzyMatch(text, bannedWord, threshold) {
  text = text.toLowerCase();
  bannedWord = bannedWord.toLowerCase();
  const L = bannedWord.length;
  const dynamicThreshold = Math.max(threshold, 1 / L);
  if (text.length < L) {
    const d = levenshteinDistance(text, bannedWord);
    return (d <= dynamicThreshold * L);
  }
  for (let i = 0; i <= text.length - L; i++) {
    const sub = text.substring(i, i + L);
    const d = levenshteinDistance(sub, bannedWord);
    if (d <= dynamicThreshold * L) return true;
  }
  return false;
}

function fuzzyContains(text, bannedWords, threshold) {
  for (let i = 0; i < bannedWords.length; i++) {
    const word = bannedWords[i];
    if (word.length < 3) {
      if (text.includes(word)) return true;
    } else if (fuzzyMatch(text, word, threshold)) return true;
  }
  return false;
}

// ========== å®‰å…¨æ£€æµ‹å›¾ç‰‡ï¼ˆGoogle Cloud Vision APIï¼‰ ==========
function analyzePhotoSafeSearch(file_id) {
  let fileResponse = sendRequest("getFile", { file_id: file_id });
  if (!fileResponse || !fileResponse.ok) {
    Logger.log("è·å–å›¾ç‰‡æ–‡ä»¶å¤±è´¥");
    return false;
  }
  let filePath = fileResponse.result.file_path;
  let fileUrl = `https://api.telegram.org/file/bot${TOKEN}/${filePath}`;
  let imageResponse = UrlFetchApp.fetch(fileUrl);
  let imageBlob = imageResponse.getBlob();
  let base64Image = Utilities.base64Encode(imageBlob.getBytes());
  let visionApiKey = 'YOUR_VISION_API_KEY'; // è¯·æ›¿æ¢ä¸ºæ‚¨çš„ Google Cloud Vision API å¯†é’¥
  let visionUrl = `https://vision.googleapis.com/v1/images:annotate?key=${visionApiKey}`;
  let requestPayload = { requests: [{ image: { content: base64Image }, features: [{ type: "SAFE_SEARCH_DETECTION" }] }] };
  let visionOptions = { method: "post", contentType: "application/json", payload: JSON.stringify(requestPayload) };
  try {
    let visionResponse = UrlFetchApp.fetch(visionUrl, visionOptions);
    let visionResult = JSON.parse(visionResponse.getContentText());
    if (visionResult.responses && visionResult.responses[0] && visionResult.responses[0].safeSearchAnnotation) {
      let safeSearch = visionResult.responses[0].safeSearchAnnotation;
      if (safeSearch.adult === "VERY_LIKELY" || safeSearch.adult === "LIKELY" ||
          safeSearch.violence === "VERY_LIKELY" || safeSearch.violence === "LIKELY" ||
          safeSearch.racy === "VERY_LIKELY" || safeSearch.racy === "LIKELY") {
        Logger.log("æ£€æµ‹åˆ°è¿è§„å›¾ç‰‡");
        return true;
      }
    }
  } catch (err) {
    Logger.log("analyzePhotoSafeSearch é”™è¯¯: " + err.toString());
  }
  return false;
}

// ========== èœå•åŠè®¾ç½®é¢æ¿ ==========
function sendMenu(chatId) {
  sendMessage(chatId, "è¯·é€‰æ‹©ä¸€ä¸ªé€‰é¡¹ï¼š", {
    reply_markup: {
      inline_keyboard: [
        [{ text: "æŒ‰é’®1", callback_data: "æŒ‰é’®1" }, { text: "æŒ‰é’®2", callback_data: "æŒ‰é’®2" }],
        [{ text: "æŒ‰é’®3", callback_data: "æŒ‰é’®3" }, { text: "æŒ‰é’®4", callback_data: "æŒ‰é’®4" }],
        [{ text: "æŒ‰é’®5", callback_data: "æŒ‰é’®5" }, { text: "æŒ‰é’®6", callback_data: "æŒ‰é’®6" }],
        [{ text: "è¿”å›ä¸»èœå•", callback_data: "è¿”å›ä¸»èœå•" }]
      ]
    }
  });
  sendKeyboard(chatId);
}

function sendSettingsMenu(chatId) {
  sendMessage(chatId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
}

function buildSettingsMarkup() {
  const settings = [
    { text: `è¿è§„æ£€æµ‹: ${getFilterEnabled() ? "âœ…" : "âŒ"}`, callback: "toggle_filter" },
    { text: `æ¨¡ç³Šè¿ç¦è¯: ${getFuzzyMatchEnabled() ? "âœ…" : "âŒ"}`, callback: "toggle_fuzzy" },
    { text: `è½¬å‘æ£€æµ‹: ${getForwardFilterEnabled() ? "âœ…" : "âŒ"}`, callback: "toggle_forward_filter" },
    { text: `è‰²æƒ…åª’ä½“: ${getPornMediaFilterEnabled() ? "âœ…" : "âŒ"}`, callback: "toggle_porn_media" },
    { text: "æ¨¡ç³Šè¿ç¦è¯ç®¡ç†", callback: "manage_fuzzy" },
    { text: `æ¬¢è¿æ¶ˆæ¯: ${getWelcomeEnabled() ? "âœ…" : "âŒ"}`, callback: "toggle_welcome" },
    { text: "è®¾ç½®æ¬¢è¿æ¶ˆæ¯", callback: "manage_welcome" },
    { text: "å…³é”®è¯å›å¤", callback: "manage_replies" },
    { text: "ç®¡ç†å®šæ—¶æ¶ˆæ¯", callback: "manage_scheduled_tasks" },
    { text: `ç¦è¨€æ—¶é•¿: ${formatDuration(getMuteDuration())}`, callback: "cycle_mute_duration" },
    { text: `è­¦å‘Šæ¬¡æ•°: ${getWarningLimit()}`, callback: "cycle_warning_limit" },
    { text: `å¤„ç½šæç¤º: ${getPunishmentAutoDeleteDuration()}ç§’`, callback: "cycle_punishment_auto_delete" },
    { text: `ç¾¤æç¤º: ${getEventAutoDeleteDuration()}ç§’`, callback: "cycle_event_auto_delete" },
    { text: `æ¬¢è¿è‡ªåŠ¨åˆ é™¤: ${getWelcomeAutoDeleteDuration()}ç§’`, callback: "cycle_welcome_autodelete" },
    { text: `å›å¤è‡ªåŠ¨åˆ é™¤: ${getReplyAutoDeleteDuration() / 60}åˆ†é’Ÿ`, callback: "cycle_reply_autodelete" },
    { text: `ç½®é¡¶åˆ é™¤: ${getPinAutoDeleteEnabled() ? "âœ…" : "âŒ"}`, callback: "toggle_pin_delete" },
    { text: `åˆ é™¤å·²é”€å·ç”¨æˆ·: ${getDeleteInactiveEnabled() ? "âœ…" : "âŒ"}`, callback: "toggle_delete_inactive" },
    { text: `è±å…ç®¡ç†å‘˜: ${getAdminExempt() ? "âœ…" : "âŒ"}`, callback: "toggle_admin_exempt" },
    { text: `æ•°å­¦éªŒè¯: ${getMathVerificationEnabled() ? "âœ…" : "âŒ"}`, callback: "toggle_math_verification" },
    { text: `å¤œé—´æ¨¡å¼: ${getNightModeEnabled() ? "âœ…" : "âŒ"}`, callback: "toggle_night_mode" },
    { text: "æˆ‘çš„ç¾¤ç»„", callback: "show_groups" },
    { text: "è¿”å›ä¸»èœå•", callback: "back_to_menu" }
  ];

  const inlineKeyboard = [];
  for (let i = 0; i < settings.length; i += 2) {
    const row = [settings[i]];
    if (i + 1 < settings.length) row.push(settings[i + 1]);
    inlineKeyboard.push(row.map(s => ({ text: s.text, callback_data: s.callback })));
  }
  return { inline_keyboard: inlineKeyboard };
}

function sendKeyboard(chatId) {
  sendMessage(chatId, "è¯·é€‰æ‹©è¾“å…¥é€‰é¡¹ï¼š", {
    reply_markup: {
      keyboard: [["é€‰é¡¹A", "é€‰é¡¹B", "é€‰é¡¹C"], ["é€‰é¡¹D", "é€‰é¡¹E", "è¿”å›ä¸»èœå•"]],
      resize_keyboard: true,
      one_time_keyboard: false
    }
  });
}

// ========== å…³é”®è¯å›å¤ç®¡ç†èœå• ==========
function sendReplySettingsMenu(chatId) {
  const customReplies = getCustomReplies();
  let replyText = "ã€å½“å‰å…³é”®è¯å›å¤åˆ—è¡¨ã€‘\n";
  for (let key in customReplies) {
    if (customReplies.hasOwnProperty(key)) {
      let r = customReplies[key];
      replyText += `\nå…³é”®è¯ï¼š${key}\nç±»å‹ï¼š${r.type}\nå†…å®¹ï¼š${r.type === "text" ? r.content : r.media}\né“¾æ¥ï¼š${r.url || "æ— "}\n`;
      if (r.caption) replyText += `è¯´æ˜ï¼š${r.caption}\n`;
    }
  }
  replyText += "\nç®¡ç†æç¤ºï¼š\n- æ·»åŠ /æ›´æ–°ï¼š/addreply å…³é”®è¯|ç±»å‹|å†…å®¹[|é“¾æ¥|è¯´æ˜]\n- åˆ é™¤ï¼š/delreply å…³é”®è¯\n- æˆ–ç‚¹å‡»ã€æ·»åŠ å…³é”®è¯å›å¤ã€‘æŒ‰é’®è¿›è¡Œå¼•å¯¼å¼è®¾ç½®\nï¼ˆç±»å‹å¯ä¸º text, photo, video, audio, documentï¼‰";
  let markup = {
    inline_keyboard: [
      [{ text: "åˆ·æ–°åˆ—è¡¨", callback_data: "refresh_replies" }],
      [{ text: "æ·»åŠ å…³é”®è¯å›å¤", callback_data: "add_reply" }],
      [{ text: "è¿”å›è®¾ç½®é¢æ¿", callback_data: "back_settings" }]
    ]
  };
  sendMessage(chatId, replyText, { reply_markup: markup });
}

// ========== è‡ªå®šä¹‰æ¨¡ç³Šè¿ç¦è¯ç®¡ç†èœå• ==========
function sendFuzzySettingsMenu(chatId) {
  const fuzzyWords = getFuzzyBannedWords();
  let replyText = "ã€å½“å‰è‡ªå®šä¹‰æ¨¡ç³Šè¿ç¦è¯åˆ—è¡¨ã€‘\n";
  if (fuzzyWords.length === 0) replyText += "æš‚æ— è‡ªå®šä¹‰æ¨¡ç³Šè¿ç¦è¯ã€‚\n";
  else fuzzyWords.forEach(word => replyText += `- ${word}\n`);
  replyText += "\nç®¡ç†æç¤ºï¼š\nç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¯åˆ é™¤å¯¹åº”çš„è¿ç¦è¯ï¼Œæˆ–ç‚¹å‡»ã€æ·»åŠ æ¨¡ç³Šè¿ç¦è¯ã€‘æŒ‰é’®æ·»åŠ æ–°è¿ç¦è¯ã€‚";
  let inlineKeyboard = [];
  if (fuzzyWords.length > 0) fuzzyWords.forEach(word => inlineKeyboard.push([{ text: `åˆ é™¤ã€${word}ã€‘`, callback_data: "del_fuzzy:" + encodeURIComponent(word) }]));
  inlineKeyboard.push([{ text: "æ·»åŠ æ¨¡ç³Šè¿ç¦è¯", callback_data: "add_fuzzy" }]);
  inlineKeyboard.push([{ text: "åˆ·æ–°åˆ—è¡¨", callback_data: "refresh_fuzzy" }]);
  inlineKeyboard.push([{ text: "è¿”å›è®¾ç½®é¢æ¿", callback_data: "back_settings" }]);
  sendMessage(chatId, replyText, { reply_markup: { inline_keyboard: inlineKeyboard } });
}

// ========== æ¬¢è¿æ¶ˆæ¯è®¾ç½®èœå• ==========
function sendWelcomeSettingsMenu(chatId) {
  let welcome = getWelcomeMessage();
  let msg = "ã€å½“å‰æ¬¢è¿æ¶ˆæ¯è®¾ç½®ã€‘\n";
  msg += "ç±»å‹: " + welcome.type + "\n";
  if (welcome.type === "text") msg += "å†…å®¹: " + welcome.content + "\n";
  else {
    msg += "åª’ä½“: " + welcome.media + "\n";
    msg += "è¯´æ˜: " + (welcome.caption || "") + "\n";
  }
  msg += "æŒ‰é’®: " + (welcome.buttons && welcome.buttons.length > 0 ? welcome.buttons.map(b => `${b.text} (${b.url})`).join(", ") : "æ— ") + "\n";
  msg += "\nç®¡ç†æç¤ºï¼š\nç‚¹å‡»ã€ä¿®æ”¹æ¬¢è¿æ¶ˆæ¯ã€‘æŒ‰é’®ï¼Œé€šè¿‡å¼•å¯¼å¼è®¾ç½®æ›´æ–°æ¬¢è¿æ¶ˆæ¯ï¼Œå¯æ·»åŠ å¤šä¸ªè¶…çº§é“¾æ¥æŒ‰é’®ï¼ˆå¯é€‰ï¼‰ã€‚";
  let markup = { inline_keyboard: [[{ text: "ä¿®æ”¹æ¬¢è¿æ¶ˆæ¯", callback_data: "edit_welcome" }], [{ text: "è¿”å›è®¾ç½®é¢æ¿", callback_data: "back_settings" }]] };
  sendMessage(chatId, msg, { reply_markup: markup });
}

// ========== å®šæ—¶æ¶ˆæ¯ç®¡ç†èœå• ==========
function sendScheduledTasksMenu(chatId) {
  let tasks = getScheduledTasks();
  let text = "ã€å®šæ—¶æ¶ˆæ¯åˆ—è¡¨ã€‘\n";
  if (tasks.length === 0) text += "æš‚æ— å®šæ—¶æ¶ˆæ¯ã€‚\n";
  else tasks.forEach(task => {
    text += `\nID: ${task.id.substring(0, 8)}...\nç¾¤ID: ${task.chatId}\næ—¶é—´: ${new Date(task.time).toLocaleString()}\nç±»å‹: ${task.type}\nå†…å®¹: ${task.content}\næŒ‰é’®: ${task.buttons.map(b => b.text).join(", ")}\né‡å¤: ${task.repeat}\nCaption: ${task.caption || "æ— "}\n`;
  });
  text += `\nå½“å‰å®šæ—¶æ¶ˆæ¯æ•°é‡ï¼š${tasks.length}/20\nç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ç®¡ç†å®šæ—¶æ¶ˆæ¯ã€‚`;
  let inlineKeyboard = [];
  tasks.forEach(task => {
    inlineKeyboard.push([
      { text: `ç¼–è¾‘ ${task.id.substring(0, 8)}`, callback_data: "edit_task:" + task.id },
      { text: `åˆ é™¤ ${task.id.substring(0, 8)}`, callback_data: "delete_task:" + task.id }
    ]);
  });
  inlineKeyboard.push([{ text: "æ·»åŠ å®šæ—¶æ¶ˆæ¯", callback_data: "add_task" }]);
  inlineKeyboard.push([{ text: "åˆ·æ–°åˆ—è¡¨", callback_data: "refresh_tasks" }]);
  inlineKeyboard.push([{ text: "è¿”å›è®¾ç½®é¢æ¿", callback_data: "back_settings" }]);
  sendMessage(chatId, text, { reply_markup: { inline_keyboard: inlineKeyboard } });
}

// ========== æŒ‰é’®å›è°ƒå¤„ç† ==========
function handleCallback(query) {
  sendRequest("answerCallbackQuery", { callback_query_id: query.id });
  const chatId = query.message.chat.id;
  const messageId = query.message.message_id;
  const data = query.data;
  const senderId = query.from.id;

  Logger.log(`å¤„ç†å›è°ƒ: chatId=${chatId}, data=${data}`);

  if (!isCreator(senderId) && (
    data === "manage_scheduled_tasks" || data === "add_task" || data.startsWith("edit_task:") || 
    data.startsWith("delete_task:") || data === "toggle_night_mode" || data === "edit_welcome" || 
    data === "manage_welcome" || data === "toggle_delete_inactive" || data === "add_reply" || 
    data === "manage_replies" || data === "manage_fuzzy"
  )) {
    sendMessage(chatId, "âŒ åªæœ‰æœºå™¨äººåˆ›å»ºè€…å¯ä»¥æ‰§è¡Œæ­¤æ“ä½œ");
    return;
  }

  if (data === "manage_scheduled_tasks") sendScheduledTasksMenu(chatId);
  else if (data === "add_task") {
    let cache = CacheService.getScriptCache();
    clearUserOperations(senderId);
    sendTaskSetupMessage(chatId, "chatId", {});
  }
  else if (data.startsWith("edit_task:")) {
    let taskId = data.substring("edit_task:".length);
    let tasks = getScheduledTasks();
    let task = tasks.find(t => t.id === taskId);
    if (!task) { sendMessage(chatId, "å®šæ—¶æ¶ˆæ¯ä¸å­˜åœ¨"); return; }
    let inlineKeyboard = [
      [{ text: "ç¼–è¾‘ç¾¤ID", callback_data: "edit_task_field:" + taskId + ":chatId" }],
      [{ text: "ç¼–è¾‘æ—¶é—´", callback_data: "edit_task_field:" + taskId + ":time" }],
      [{ text: "ç¼–è¾‘ç±»å‹", callback_data: "edit_task_field:" + taskId + ":type" }],
      [{ text: "ç¼–è¾‘å†…å®¹", callback_data: "edit_task_field:" + taskId + ":content" }],
      [{ text: "ç¼–è¾‘æŒ‰é’®", callback_data: "edit_task_field:" + taskId + ":buttons" }],
      [{ text: "ç¼–è¾‘é‡å¤å‘¨æœŸ", callback_data: "edit_task_field:" + taskId + ":repeat" }],
      [{ text: "ç¼–è¾‘Caption", callback_data: "edit_task_field:" + taskId + ":caption" }],
      [{ text: "è¿”å›", callback_data: "manage_scheduled_tasks" }]
    ];
    sendMessage(chatId, "è¯·é€‰æ‹©è¦ç¼–è¾‘çš„å­—æ®µï¼š", { reply_markup: { inline_keyboard: inlineKeyboard } });
  }
  else if (data.startsWith("edit_task_field:")) {
    let parts = data.split(":");
    let taskId = parts[1];
    let field = parts[2];
    let tasks = getScheduledTasks();
    let task = tasks.find(t => t.id === taskId);
    if (!task) { sendMessage(chatId, "å®šæ—¶æ¶ˆæ¯ä¸å­˜åœ¨"); return; }
    let currentValue;
    let prompt;
    switch (field) {
      case "chatId":
        currentValue = task.chatId;
        prompt = "è¯·å‘é€æ–°çš„ç›®æ ‡ç¾¤IDï¼ˆä¾‹å¦‚ -123456789ï¼‰";
        break;
      case "time":
        currentValue = new Date(task.time).toLocaleString();
        prompt = "è¯·å‘é€æ–°çš„å‘é€æ—¶é—´ï¼ˆæ ¼å¼ï¼šYYYY-MM-DD HH:MM:SSï¼Œä¾‹å¦‚ 2023-12-31 23:59:59ï¼‰";
        break;
      case "type":
        currentValue = task.type;
        prompt = "è¯·å‘é€æ–°çš„æ¶ˆæ¯ç±»å‹ï¼ˆtext, photo, video, audio, documentï¼‰";
        break;
      case "content":
        currentValue = task.content;
        prompt = "è¯·å‘é€æ–°çš„æ¶ˆæ¯å†…å®¹ï¼ˆå¯¹äºtextæ˜¯æ–‡æœ¬ï¼Œå¯¹äºå…¶ä»–æ˜¯åª’ä½“URLï¼Œä¾‹å¦‚ https://example.com/image.jpgï¼‰";
        break;
      case "buttons":
        currentValue = task.buttons.length > 0 ? task.buttons.map(b => `${b.text},${b.url}`).join(", ") : "æ— ";
        prompt = "è¯·å‘é€æ–°çš„æŒ‰é’®ä¿¡æ¯ï¼Œæ ¼å¼ï¼šæ–‡æœ¬1,URL1,æ–‡æœ¬2,URL2,...ï¼ˆå¤šä¸ªæŒ‰é’®ç”¨é€—å·åˆ†éš”ï¼Œä¾‹å¦‚ æŒ‰é’®1,https://example.com/1,æŒ‰é’®2,https://example.com/2ï¼‰";
        break;
      case "repeat":
        currentValue = task.repeat;
        prompt = "è¯·å‘é€æ–°çš„é‡å¤å‘¨æœŸï¼ˆnone, hourly, daily, weekly, monthlyï¼‰";
        break;
      case "caption":
        currentValue = task.caption || "æ— ";
        prompt = "è¯·å‘é€æ–°çš„captionï¼ˆå¯é€‰ï¼ŒæŒ‰ Enter è·³è¿‡ï¼‰";
        break;
      default:
        sendMessage(chatId, "æœªçŸ¥å­—æ®µ");
        return;
    }
    let cache = CacheService.getScriptCache();
    cache.put("EDIT_TASK_" + senderId, JSON.stringify({ taskId: taskId, field: field }), 300);
    sendMessage(chatId, `å½“å‰${field}ï¼š${currentValue}\n${prompt}`);
  }
  else if (data.startsWith("delete_task:")) {
    let taskId = data.substring("delete_task:".length);
    deleteScheduledTask(taskId);
    sendMessage(chatId, `å®šæ—¶æ¶ˆæ¯ ${taskId.substring(0, 8)} å·²åˆ é™¤`);
    sendScheduledTasksMenu(chatId);
  }
  else if (data === "refresh_tasks") sendScheduledTasksMenu(chatId);
  else if (data === "manage_welcome") sendWelcomeSettingsMenu(chatId);
  else if (data === "toggle_filter") {
    setFilterEnabled(!getFilterEnabled());
    editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
  }
  else if (data === "toggle_fuzzy") {
    setFuzzyMatchEnabled(!getFuzzyMatchEnabled());
    editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
  }
  else if (data === "toggle_forward_filter") {
    setForwardFilterEnabled(!getForwardFilterEnabled());
    editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
  }
  else if (data === "toggle_porn_media") {
    setPornMediaFilterEnabled(!getPornMediaFilterEnabled());
    editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
  }
  else if (data === "toggle_welcome") {
    setWelcomeEnabled(!getWelcomeEnabled());
    editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
  }
  else if (data === "toggle_admin_exempt") {
    setAdminExempt(!getAdminExempt());
    editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
  }
  else if (data === "toggle_math_verification") {
    setMathVerificationEnabled(!getMathVerificationEnabled());
    editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
  }
  else if (data === "cycle_welcome_autodelete") cycleWelcomeAutoDelete(chatId, messageId);
  else if (data === "cycle_reply_autodelete") cycleReplyAutoDelete(chatId, messageId);
  else if (data === "cycle_mute_duration") cycleMuteDuration(chatId, messageId);
  else if (data === "cycle_warning_limit") cycleWarningLimit(chatId, messageId);
  else if (data === "cycle_punishment_auto_delete") cyclePunishmentAutoDelete(chatId, messageId);
  else if (data === "cycle_event_auto_delete") cycleEventAutoDelete(chatId, messageId);
  else if (data === "manage_replies") sendReplySettingsMenu(chatId);
  else if (data === "manage_fuzzy") sendFuzzySettingsMenu(chatId);
  else if (data === "refresh_fuzzy") sendFuzzySettingsMenu(chatId);
  else if (data === "edit_welcome") {
    let cache = CacheService.getScriptCache();
    clearUserOperations(senderId);
    cache.put("EDIT_WELCOME_" + senderId, JSON.stringify({ step: "type" }), 300);
    sendMessage(chatId, "è¯·å‘é€æ¬¢è¿æ¶ˆæ¯ç±»å‹ï¼ˆtext, photo, video, audio, documentï¼‰ï¼š");
  }
  else if (data === "add_fuzzy") {
    let cache = CacheService.getScriptCache();
    clearUserOperations(senderId);
    cache.put("TEMP_FUZZY_" + senderId, chatId.toString(), 300);
    sendMessage(chatId, "è¯·ç›´æ¥å‘é€è¦æ·»åŠ çš„æ¨¡ç³Šè¿ç¦è¯ï¼Œç”¨é€—å·ï¼ˆ, æˆ– ï¼Œï¼‰åˆ†éš”å¤šä¸ªè¯è¯­ã€‚");
  }
  else if (data.startsWith("del_fuzzy:")) {
    let wordEncoded = data.substring("del_fuzzy:".length);
    let word = decodeURIComponent(wordEncoded);
    let fuzzyWords = getFuzzyBannedWords();
    let index = fuzzyWords.indexOf(word);
    if (index !== -1) {
      fuzzyWords.splice(index, 1);
      setFuzzyBannedWords(fuzzyWords);
      sendMessage(chatId, `è‡ªå®šä¹‰æ¨¡ç³Šè¿ç¦è¯ "${word}" å·²åˆ é™¤`);
    } else sendMessage(chatId, `è‡ªå®šä¹‰æ¨¡ç³Šè¿ç¦è¯ "${word}" ä¸å­˜åœ¨`);
    sendFuzzySettingsMenu(chatId);
  }
  else if (data === "refresh_replies") sendReplySettingsMenu(chatId);
  else if (data === "back_settings") {
    clearUserOperations(senderId);
    sendSettingsMenu(chatId);
  }
  else if (data === "show_groups") showGroupList(chatId);
  else if (data === "back_to_menu") sendMenu(chatId);
  else if (data === "toggle_pin_delete") {
    let newState = !getPinAutoDeleteEnabled();
    setPinAutoDeleteEnabled(newState);
    setupPinAutoDeleteTrigger();
    editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
    sendMessage(chatId, `ç½®é¡¶æ¶ˆæ¯è‡ªåŠ¨åˆ é™¤å·²${newState ? "å¼€å¯" : "å…³é—­"}ï¼Œæ£€æŸ¥é—´éš” ${getPinAutoDeleteInterval()} åˆ†é’Ÿã€‚`);
  }
else if (data === "toggle_night_mode") {
    let newState = !getNightModeEnabled();
    setNightModeEnabled(newState);
    editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
    sendMessage(chatId, `å¤œé—´æ¨¡å¼å·²${newState ? "å¯ç”¨" : "å…³é—­"}ï¼Œæ—¶é—´æ®µ ${getNightModeStart()} - ${getNightModeEnd()}ï¼Œæ—¶åŒº UTC${getNightModeOffset() >= 0 ? "+" : ""}${getNightModeOffset()}`);
  }
  else if (data === "toggle_delete_inactive") {
    let newState = !getDeleteInactiveEnabled();
    setDeleteInactiveEnabled(newState);
    setupInactiveUserTrigger();
    editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
    sendMessage(chatId, `åˆ é™¤å·²é”€å·ç”¨æˆ·åŠŸèƒ½å·²${newState ? "å¼€å¯" : "å…³é—­"}ï¼Œæ¯å¤©æ£€æŸ¥ä¸€æ¬¡ã€‚`);
  }
  else if (data === "add_reply") {
    let cache = CacheService.getScriptCache();
    clearUserOperations(senderId);
    cache.put("ADD_reply_" + senderId, JSON.stringify({ step: "keyword" }), 300);
    sendMessage(chatId, "è¯·å‘é€ä½ è¦æ·»åŠ çš„å…³é”®è¯ï¼š");
  }
  else {
    const customReplies = getCustomReplies();
    if (customReplies[data]) sendCustomReply(chatId, customReplies[data]);
    else sendMessage(chatId, "æœªæ‰¾åˆ°è‡ªå®šä¹‰å›å¤: " + data);
  }
}

function cycleMuteDuration(chatId, messageId) {
  const durations = [3600, 21600, 86400];
  let current = getMuteDuration();
  let idx = durations.indexOf(current);
  if (idx === -1) idx = 0;
  let newDuration = durations[(idx + 1) % durations.length];
  setMuteDuration(newDuration);
  editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
}

function cycleWarningLimit(chatId, messageId) {
  const limits = [1, 2, 3, 5];
  let current = getWarningLimit();
  let idx = limits.indexOf(current);
  if (idx === -1) idx = 2;
  let newLimit = limits[(idx + 1) % limits.length];
  setWarningLimit(newLimit);
  editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
}

function cyclePunishmentAutoDelete(chatId, messageId) {
  const durations = [0, 5, 10, 20, 30];
  let current = getPunishmentAutoDeleteDuration();
  let idx = durations.indexOf(current);
  if (idx === -1) idx = 2;
  let newDuration = durations[(idx + 1) % durations.length];
  setPunishmentAutoDeleteDuration(newDuration);
  editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
}

function cycleEventAutoDelete(chatId, messageId) {
  const durations = [0, 5, 10, 20, 30];
  let current = getEventAutoDeleteDuration();
  let idx = durations.indexOf(current);
  if (idx === -1) idx = 2;
  let newDuration = durations[(idx + 1) % durations.length];
  setEventAutoDeleteDuration(newDuration);
  editMessage(chatId, messageId, "âš™ï¸ è®¾ç½®é¢æ¿ï¼š", { reply_markup: buildSettingsMarkup() });
}

function formatDuration(seconds) {
  return (seconds / 3600) + "å°æ—¶";
}

// ========== ç®¡ç†å‘˜æ£€æŸ¥ ==========
function isAdmin(chatId, userId) {
  if (chatId > 0) return true;
  let cache = CacheService.getScriptCache();
  let key = `ADMIN_${chatId}_${userId}`;
  let cached = cache.get(key);
  if (cached !== null) return cached === "true";
  try {
    let response = UrlFetchApp.fetch(`${BASE_URL}getChatMember?chat_id=${chatId}&user_id=${userId}`);
    let data = JSON.parse(response.getContentText());
    let isAdmin = data.ok && (data.result.status === "creator" || data.result.status === "administrator");
    cache.put(key, isAdmin.toString(), 3600);
    return isAdmin;
  } catch (error) {
    Logger.log("isAdmin æ£€æŸ¥é”™è¯¯: " + error.toString());
    return false;
  }
}

// ========== æ¶ˆæ¯å‘é€ä¸ç¼–è¾‘ ==========
function sendRequest(method, payload) {
  try {
    let response = UrlFetchApp.fetch(`${BASE_URL}${method}`, {
      method: "post",
      contentType: "application/json",
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    });
    let result = JSON.parse(response.getContentText());
    if (!result.ok) {
      Logger.log(`Error in ${method}: ${result.description}`);
      return null;
    }
    return result;
  } catch (err) {
    Logger.log(`Exception in ${method}: ${err.toString()}`);
    return null;
  }
}

function sendMessage(chatId, text, options = {}) {
  return sendRequest("sendMessage", { chat_id: chatId, text: text, ...options });
}

function sendPhoto(chatId, photoUrl, options = {}) {
  return sendRequest("sendPhoto", { chat_id: chatId, photo: photoUrl, ...options });
}

function sendVideo(chatId, videoUrl, options = {}) {
  return sendRequest("sendVideo", { chat_id: chatId, video: videoUrl, ...options });
}

function sendAudio(chatId, audioUrl, options = {}) {
  return sendRequest("sendAudio", { chat_id: chatId, audio: audioUrl, ...options });
}

function sendDocument(chatId, documentUrl, options = {}) {
  return sendRequest("sendDocument", { chat_id: chatId, document: documentUrl, ...options });
}

function editMessage(chatId, messageId, text, options = {}) {
  sendRequest("editMessageText", { chat_id: chatId, message_id: messageId, text: text, ...options });
}

// ========== Webhook è®¾ç½® ==========
function setWebhook() {
  const url = `${BASE_URL}setWebhook`;
  const params = { url: SCRIPT_URL, allowed_updates: JSON.stringify(["message", "chat_member", "callback_query"]) };
  const options = { method: "post", payload: params, muteHttpExceptions: true };
  const response = UrlFetchApp.fetch(url, options);
  const result = JSON.parse(response.getContentText());
  if (result.ok) Logger.log("Webhook è®¾ç½®æˆåŠŸ");
  else Logger.log("Webhook è®¾ç½®å¤±è´¥: " + result.description);
}

// ========== è®¾ç½®è§¦å‘å™¨ ==========
function setupTriggers() {
  setupVerificationTrigger();
  setupPinAutoDeleteTrigger();
  setupScheduledTaskTrigger();
  setupInactiveUserTrigger();
  setupDeletionTrigger();
}

function setupVerificationTrigger() {
  deleteTriggers("checkUnverifiedUsers");
  try {
    ScriptApp.newTrigger("checkUnverifiedUsers")
      .timeBased()
      .everyMinutes(1)
      .create();
    Logger.log("æœªéªŒè¯ç”¨æˆ·æ£€æŸ¥è§¦å‘å™¨å·²è®¾ç½®ä¸ºæ¯åˆ†é’Ÿè¿è¡Œ");
  } catch (err) {
    Logger.log(`è®¾ç½®æœªéªŒè¯ç”¨æˆ·æ£€æŸ¥è§¦å‘å™¨å¤±è´¥: ${err.toString()}`);
  }
}

function initialize() {
  setWebhook();
  setupTriggers();
}