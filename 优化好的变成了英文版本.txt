// ========== Basic Configuration ==========
const TOKEN = 'YOUR_BOT_TOKEN'; // Replace with your Telegram Bot Token
const BASE_URL = `https://api.telegram.org/bot${TOKEN}/`;
const SCRIPT_URL = 'YOUR_SCRIPT_DEPLOYMENT_URL'; // Replace with your Google Apps Script deployment URL
const BOT_ID = 'YOUR_BOT_ID'; // Replace with your bot's numeric ID
const BOT_CREATOR_ID = 'YOUR_CREATOR_ID'; // Replace with the Telegram ID of the bot creator

// ========== Persistent Storage ==========
const USER_LAST_MESSAGE = {}; // Tracks last message per chat to prevent spam

// ========== Default Custom Replies ==========
const DEFAULT_CUSTOM_REPLIES = {
  "按钮1": { type: "text", content: "你点击了按钮1，这是自定义文本回复！" },
  "按钮2": {
    type: "photo",
    media: "https://via.placeholder.com/300",
    caption: "这是一张图片示例",
    inline_keyboard: [[{ text: "查看详情", url: "https://example.com/details" }]]
  },
  "按钮3": {
    type: "video",
    media: "https://sample-videos.com/video123/mp4/720/big_buck_bunny_720p_1mb.mp4",
    caption: "这是一个视频示例",
    inline_keyboard: [[{ text: "观看视频", url: "https://example.com/video" }]]
  },
  "按钮4": {
    type: "document",
    media: "https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf",
    caption: "这是一个文档示例",
    inline_keyboard: [[{ text: "下载文档", url: "https://example.com/document" }]]
  },
  "按钮5": { type: "text", content: "你点击了按钮5，这是带链接按钮的回复！", inline_keyboard: [[{ text: "访问网站", url: "https://example.com" }]] },
  "按钮6": { type: "text", content: "你点击了按钮6，这是自定义回复示例！" },
  "返回主菜单": { type: "text", content: "你已返回主菜单，请选择新的选项。" },
  "选项A": { type: "text", content: "你选择了选项A，这是自定义回复！" },
  "选项B": { type: "text", content: "选项B已选中，请查看详细内容。" },
  "选项C": { type: "text", content: "你点击了选项C，系统正在处理..." },
  "选项D": { type: "text", content: "你选择了选项D，这是特别信息。" },
  "选项E": { type: "text", content: "选项E被选中，系统正在处理。" }
};

// ========== Default Welcome Message ==========
const DEFAULT_WELCOME_MESSAGE = {
  type: "text",
  content: "欢迎 {names} 加入群聊！"
};

// ========== Custom Replies Management ==========
function getCustomReplies() {
  const props = PropertiesService.getScriptProperties();
  let data = props.getProperty("CUSTOM_REPLIES");
  if (!data) {
    setCustomReplies(DEFAULT_CUSTOM_REPLIES);
    return DEFAULT_CUSTOM_REPLIES;
  }
  try {
    let replies = JSON.parse(data);
    if (!replies["按钮6"]) replies["按钮6"] = DEFAULT_CUSTOM_REPLIES["按钮6"];
    return replies;
  } catch (err) {
    Logger.log("Error parsing CUSTOM_REPLIES: " + err.toString());
    return DEFAULT_CUSTOM_REPLIES;
  }
}

function setCustomReplies(obj) {
  let jsonStr = JSON.stringify(obj);
  if (jsonStr.length > 9 * 1024) throw new Error("Data exceeds PropertiesService limit (9KB)");
  PropertiesService.getScriptProperties().setProperty("CUSTOM_REPLIES", jsonStr);
}

// ========== Welcome Message Management ==========
function getWelcomeMessage() {
  const props = PropertiesService.getScriptProperties();
  let data = props.getProperty("WELCOME_MESSAGE");
  if (!data) {
    setWelcomeMessage(DEFAULT_WELCOME_MESSAGE);
    return DEFAULT_WELCOME_MESSAGE;
  }
  try {
    return JSON.parse(data);
  } catch (err) {
    Logger.log("Error parsing WELCOME_MESSAGE: " + err.toString());
    return DEFAULT_WELCOME_MESSAGE;
  }
}

function setWelcomeMessage(obj) {
  PropertiesService.getScriptProperties().setProperty("WELCOME_MESSAGE", JSON.stringify(obj));
}

// ========== Whitelist Management ==========
function getWhitelist() {
  const props = PropertiesService.getScriptProperties();
  let data = props.getProperty("WHITELIST");
  if (!data) {
    setWhitelist([]);
    return [];
  }
  try {
    return JSON.parse(data);
  } catch (err) {
    Logger.log("Error parsing WHITELIST: " + err.toString());
    return [];
  }
}

function setWhitelist(list) {
  PropertiesService.getScriptProperties().setProperty("WHITELIST", JSON.stringify(list));
}

// ========== Timezone Management ==========
function getTimezone() {
  const props = PropertiesService.getScriptProperties();
  let timezone = props.getProperty("TIMEZONE");
  return timezone || "Asia/Shanghai"; // Default to Beijing time
}

function setTimezone(timezone) {
  PropertiesService.getScriptProperties().setProperty("TIMEZONE", timezone);
}

// ========== Settings Management ==========
function getSetting(key, defaultValue) {
  const props = PropertiesService.getScriptProperties();
  let value = props.getProperty(key);
  if (value === null) return defaultValue;
  if (typeof defaultValue === "boolean") return value === "true";
  if (typeof defaultValue === "number") return parseInt(value, 10);
  return value;
}

function setSetting(key, value) {
  PropertiesService.getScriptProperties().setProperty(key, value.toString());
}

// General settings getters and setters
function getFilterEnabled() { return getSetting("FILTER_ENABLED", true); }
function getFuzzyMatchEnabled() { return getSetting("FUZZY_MATCH_ENABLED", false); }
function getForwardFilterEnabled() { return getSetting("FORWARD_FILTER_ENABLED", true); }
function getPornMediaFilterEnabled() { return getSetting("PORN_MEDIA_FILTER_ENABLED", true); }
function getWelcomeEnabled() { return getSetting("WELCOME_ENABLED", true); }
function setWelcomeEnabled(val) { setSetting("WELCOME_ENABLED", val); }
function getAdminExempt() { return getSetting("ADMIN_EXEMPT", true); }
function setAdminExempt(val) { setSetting("ADMIN_EXEMPT", val); }
function getQuizVerificationEnabled() { return getSetting("QUIZ_VERIFICATION_ENABLED", true); }
function setQuizVerificationEnabled(val) { setSetting("QUIZ_VERIFICATION_ENABLED", val); }
function getMuteDuration() { return getSetting("MUTE_DURATION", 3600); } // 1 hour default
function getWarningLimit() { return getSetting("WARNING_LIMIT", 3); }
function getPunishmentAutoDeleteDuration() { return getSetting("PUNISHMENT_AUTO_DELETE", 10); }
function getEventAutoDeleteDuration() { return getSetting("EVENT_AUTO_DELETE", 10); }
function getWelcomeAutoDeleteDuration() { return getSetting("WELCOME_AUTO_DELETE", 0); }
function setWelcomeAutoDeleteDuration(val) { setSetting("WELCOME_AUTO_DELETE", val); }
function getReplyAutoDeleteDuration() { return getSetting("REPLY_AUTO_DELETE", 0); }
function setReplyAutoDeleteDuration(val) { setSetting("REPLY_AUTO_DELETE", val); }

// New Feature: Pinned Message Auto-Delete Settings
function getPinAutoDeleteEnabled() { return getSetting("PIN_AUTO_DELETE_ENABLED", false); }
function setPinAutoDeleteEnabled(val) { setSetting("PIN_AUTO_DELETE_ENABLED", val); }
function getPinAutoDeleteInterval() { return getSetting("PIN_AUTO_DELETE_INTERVAL", 60); }
function setPinAutoDeleteInterval(val) { setSetting("PIN_AUTO_DELETE_INTERVAL", val); }

// New Feature: Night Mode Settings
function getNightModeEnabled() { return getSetting("NIGHT_MODE_ENABLED", false); }
function setNightModeEnabled(val) { setSetting("NIGHT_MODE_ENABLED", val); }
function getNightModeStart() { return getSetting("NIGHT_MODE_START", "22:00"); }
function setNightModeStart(val) { setSetting("NIGHT_MODE_START", val); }
function getNightModeEnd() { return getSetting("NIGHT_MODE_END", "07:00"); }
function setNightModeEnd(val) { setSetting("NIGHT_MODE_END", val); }

// New Feature: Media/Link-Only Night Mode
function getOnlyMediaLinkNightModeEnabled() { return getSetting("ONLY_MEDIA_LINK_NIGHT_MODE_ENABLED", false); }
function setOnlyMediaLinkNightModeEnabled(val) { setSetting("ONLY_MEDIA_LINK_NIGHT_MODE_ENABLED", val); }

// ========== Fixed Configurations ==========
const SPAM_KEYWORDS = ["广告", "免费", "推广", "投资", "赚钱", "优惠"];
const PORN_KEYWORDS = ["裸露", "成人", "色情", "性爱", "激情"];
const LINK_PATTERN = /(https?:\/\/|www\.)\S+/i;
const FUZZY_THRESHOLD = 0.3;

// ========== Fuzzy Banned Words Management ==========
function getFuzzyBannedWords() {
  const props = PropertiesService.getScriptProperties();
  let data = props.getProperty("FUZZY_BANNED_WORDS");
  if (!data) {
    setFuzzyBannedWords([]);
    return [];
  }
  try {
    return JSON.parse(data);
  } catch (err) {
    Logger.log("Error parsing FUZZY_BANNED_WORDS: " + err.toString());
    return [];
  }
}

function setFuzzyBannedWords(words) {
  PropertiesService.getScriptProperties().setProperty("FUZZY_BANNED_WORDS", JSON.stringify(words));
}

// ========== Warning Count Management ==========
function getWarningCount(chatId, userId) {
  let key = "warn_" + chatId + "_" + userId;
  let count = PropertiesService.getScriptProperties().getProperty(key);
  return count ? parseInt(count, 10) : 0;
}

function setWarningCount(chatId, userId, count) {
  let key = "warn_" + chatId + "_" + userId;
  PropertiesService.getScriptProperties().setProperty(key, count.toString());
}

function deleteWarningCount(chatId, userId) {
  let key = "warn_" + chatId + "_" + userId;
  PropertiesService.getScriptProperties().deleteProperty(key);
}

// ========== Group Tracking ==========
function recordGroup(chatId, groupTitle) {
  const props = PropertiesService.getScriptProperties();
  let groups = JSON.parse(props.getProperty("GROUPS") || "{}");
  if (!groups[chatId]) {
    groups[chatId] = groupTitle;
    props.setProperty("GROUPS", JSON.stringify(groups));
  }
}

function showGroupList(chatId) {
  const props = PropertiesService.getScriptProperties();
  let groups = JSON.parse(props.getProperty("GROUPS") || "{}");
  let text = "机器人所在群组列表：\n";
  for (let id in groups) {
    text += `群ID: ${id}, 名称: ${groups[id]}\n`;
  }
  sendMessage(chatId, text);
}

// ========== Auto-Delete Duration Cycling ==========
function cycleWelcomeAutoDelete(chatId, messageId) {
  const durations = [0, 5, 10, 20, 30];
  let current = getWelcomeAutoDeleteDuration();
  let idx = durations.indexOf(current);
  if (idx === -1) idx = 0;
  let newDuration = durations[(idx + 1) % durations.length];
  setWelcomeAutoDeleteDuration(newDuration);
  Logger.log(`Updated welcome auto-delete from ${current} to ${newDuration} seconds`);
  editMessage(chatId, messageId, "⚙️ 设置面板：", { reply_markup: buildSettingsMarkup() });
}

function cycleReplyAutoDelete(chatId, messageId) {
  const durations = [0, 5, 10, 20, 30];
  let current = getReplyAutoDeleteDuration();
  let idx = durations.indexOf(current);
  if (idx === -1) idx = 0;
  let newDuration = durations[(idx + 1) % durations.length];
  setReplyAutoDeleteDuration(newDuration);
  Logger.log(`Updated reply auto-delete from ${current} to ${newDuration} seconds`);
  editMessage(chatId, messageId, "⚙️ 设置面板：", { reply_markup: buildSettingsMarkup() });
}

// ========== New Feature: Pinned Message Auto-Delete ==========
function deletePinnedMessages() {
  const props = PropertiesService.getScriptProperties();
  let groups = JSON.parse(props.getProperty("GROUPS") || "{}");
  for (let chatId in groups) {
    let pinnedMessage = getPinnedMessage(chatId);
    if (pinnedMessage) {
      deleteMessage(chatId, pinnedMessage.message_id);
      sendAutoDeleteMessage(chatId, `已删除置顶消息`, 10);
    }
  }
}

function getPinnedMessage(chatId) {
  let response = sendRequest("getChat", { chat_id: chatId });
  if (response.ok && response.result.pinned_message) {
    return response.result.pinned_message;
  }
  return null;
}

function setupPinAutoDeleteTrigger() {
  deleteTriggers("deletePinnedMessages");
  if (getPinAutoDeleteEnabled()) {
    let interval = getPinAutoDeleteInterval();
    ScriptApp.newTrigger("deletePinnedMessages")
      .timeBased()
      .everyMinutes(interval)
      .create();
  }
}

function deleteTriggers(functionName) {
  let triggers = ScriptApp.getProjectTriggers();
  for (let trigger of triggers) {
    if (trigger.getHandlerFunction() === functionName) {
      ScriptApp.deleteTrigger(trigger);
    }
  }
}

// ========== New Feature: Night Mode with Timezone Support ==========
function isNightModeActive() {
  if (!getNightModeEnabled() && !getOnlyMediaLinkNightModeEnabled()) return false;
  
  const timezone = getTimezone();
  const now = new Date((new Date()).toLocaleString("en-US", { timeZone: timezone }));
  let start = parseTime(getNightModeStart(), timezone);
  let end = parseTime(getNightModeEnd(), timezone);
  
  let nowMinutes = now.getHours() * 60 + now.getMinutes();
  let startMinutes = start.getHours() * 60 + start.getMinutes();
  let endMinutes = end.getHours() * 60 + end.getMinutes();
  
  if (startMinutes < endMinutes) {
    return nowMinutes >= startMinutes && nowMinutes < endMinutes;
  } else {
    return nowMinutes >= startMinutes || nowMinutes < endMinutes;
  }
}

function parseTime(timeStr, timezone) {
  let [hours, minutes] = timeStr.split(":").map(Number);
  let date = new Date();
  date = new Date(date.toLocaleString("en-US", { timeZone: timezone }));
  date.setHours(hours, minutes, 0, 0);
  return date;
}

// ========== Main Handler Function ==========
function doPost(e) {
  try {
    if (!e || !e.postData || !e.postData.contents) return;
    const update = JSON.parse(e.postData.contents);

    if (update.callback_query) {
      handleCallback(update.callback_query);
      return;
    }

    if (update.chat_member) {
      handleChatMemberUpdate(update.chat_member);
      return;
    }

    if (!update.message) return;

    const message = update.message;
    const chatId = message.chat.id;
    const senderId = message.from.id;
    const text = message.text;
    const message_id = message.message_id;
    Logger.log(`Received message: chatId=${chatId}, senderId=${senderId}, text=${text}`);

    if (chatId < 0) {
      let groupTitle = message.chat.title || "Unknown Group";
      recordGroup(chatId, groupTitle);
    }
    if (chatId < 0 && senderId === Number(BOT_ID)) return;

    let isSenderAdmin = isAdmin(chatId, senderId);
    let whitelist = getWhitelist();
    let isWhitelisted = whitelist.includes(senderId.toString());

    // Night Mode Handling
    if (chatId < 0 && isNightModeActive() && !isSenderAdmin && !isWhitelisted) {
      let deleted = false;
      if (getOnlyMediaLinkNightModeEnabled() && (message.photo || (text && LINK_PATTERN.test(text)))) {
        deleteMessage(chatId, message_id);
        sendAutoDeleteMessage(chatId, "Night mode (media/links only) enabled, message deleted.", 10);
        deleted = true;
      }
      if (getNightModeEnabled() && !deleted) {
        deleteMessage(chatId, message_id);
        sendAutoDeleteMessage(chatId, "Night mode enabled, non-admin messages deleted.", 10);
        return;
      }
      if (deleted) return;
    }

    // Admin Command Handling
    if (text && isSenderAdmin) {
      if (text.startsWith("/addreply") || text.startsWith("/editreply")) {
        let params = text.substring(text.indexOf(" ") + 1).trim();
        let parts = params.split("|");
        if (parts.length < 3) {
          return sendMessage(chatId, "Format error: /addreply keyword|type|content[|caption], type: text, photo, video, document");
        }
        let keyword = parts[0].trim();
        let type = parts[1].trim();
        let content = parts[2].trim();
        let replyObj = { type: type };
        if (type === "text") {
          replyObj.content = content;
        } else if (["photo", "video", "document"].includes(type)) {
          replyObj.media = content;
          if (parts.length >= 4) replyObj.caption = parts[3].trim();
        } else {
          return sendMessage(chatId, "Unknown type, use: text, photo, video, document");
        }
        let customReplies = getCustomReplies();
        customReplies[keyword] = replyObj;
        setCustomReplies(customReplies);
        Logger.log(`Added/Updated reply: ${keyword} -> ${JSON.stringify(replyObj)}`);
        return sendMessage(chatId, `Reply "${keyword}" added/updated`);
      }
      if (text.startsWith("/delreply")) {
        let keyword = text.substring(9).trim();
        let customReplies = getCustomReplies();
        if (customReplies.hasOwnProperty(keyword)) {
          delete customReplies[keyword];
          setCustomReplies(customReplies);
          Logger.log(`Deleted reply: ${keyword}`);
          return sendMessage(chatId, `Reply "${keyword}" deleted`);
        }
        return sendMessage(chatId, `Reply "${keyword}" not found`);
      }
      if (text.startsWith("/delfuzzy")) {
        let params = text.substring(text.indexOf(" ") + 1).trim();
        let fuzzyWords = getFuzzyBannedWords();
        let index = fuzzyWords.indexOf(params);
        if (index !== -1) {
          fuzzyWords.splice(index, 1);
          setFuzzyBannedWords(fuzzyWords);
          Logger.log(`Deleted fuzzy banned word: ${params}`);
          return sendMessage(chatId, `Fuzzy banned word "${params}" deleted`);
        }
        return sendMessage(chatId, `Fuzzy banned word "${params}" not found`);
      }
      if (text.startsWith("/clearwarnings")) {
        if (message.reply_to_message && message.reply_to_message.from) {
          let targetUser = message.reply_to_message.from;
          deleteWarningCount(chatId, targetUser.id);
          return sendMessage(chatId, `Warnings cleared for user ${targetUser.id}`);
        }
        let parts = text.split(" ");
        if (parts.length < 2) {
          return sendMessage(chatId, "Reply to a user or use: /clearwarnings userID");
        }
        let targetUserId = parts[1].trim();
        deleteWarningCount(chatId, targetUserId);
        return sendMessage(chatId, `Warnings cleared for user ${targetUserId}`);
      }
      if (text.startsWith("/stats")) {
        let allProps = PropertiesService.getScriptProperties().getProperties();
        let statsText = "Current warning stats:\n";
        for (let key in allProps) {
          if (key.indexOf("warn_" + chatId + "_") === 0) {
            let parts = key.split("_");
            let userId = parts[2];
            let count = allProps[key];
            statsText += `User ${userId} warnings: ${count}\n`;
          }
        }
        if (statsText === "Current warning stats:\n") statsText += "No warnings.";
        return sendMessage(chatId, statsText);
      }
      if (text.startsWith("/addwhitelist")) {
        let userId = text.substring(12).trim();
        let whitelist = getWhitelist();
        if (!whitelist.includes(userId)) {
          whitelist.push(userId);
          setWhitelist(whitelist);
          return sendMessage(chatId, `User ${userId} added to whitelist`);
        }
        return sendMessage(chatId, `User ${userId} already in whitelist`);
      }
      if (text.startsWith("/delwhitelist")) {
        let userId = text.substring(12).trim();
        let whitelist = getWhitelist();
        let index = whitelist.indexOf(userId);
        if (index !== -1) {
          whitelist.splice(index, 1);
          setWhitelist(whitelist);
          return sendMessage(chatId, `User ${userId} removed from whitelist`);
        }
        return sendMessage(chatId, `User ${userId} not in whitelist`);
      }
      if (text.startsWith("/settimezone")) {
        let parts = text.split(" ");
        if (parts.length < 2) {
          return sendMessage(chatId, "Format error: /settimezone timezone\nE.g., /settimezone Asia/Shanghai");
        }
        let timezone = parts[1].trim();
        try {
          new Date().toLocaleString("en-US", { timeZone: timezone });
          setTimezone(timezone);
          return sendMessage(chatId, `Timezone set to ${timezone}, current time: ${new Date().toLocaleString("en-US", { timeZone: timezone })}`);
        } catch (err) {
          return sendMessage(chatId, `Invalid timezone: ${timezone}, use IANA timezone (e.g., Asia/Shanghai)`);
        }
      }
      const cacheWelcome = CacheService.getScriptCache();
      const welcomeFlag = cacheWelcome.get("TEMP_WELCOME_" + senderId);
      if (welcomeFlag !== null) {
        let parts = text.split("|");
        if (parts.length < 2) {
          sendMessage(chatId, "Format error: type|content[|caption], type: text, photo, video, document");
          cacheWelcome.remove("TEMP_WELCOME_" + senderId);
          return;
        }
        let type = parts[0].trim();
        if (!["text", "photo", "video", "document"].includes(type)) {
          sendMessage(chatId, "Unknown type, use: text, photo, video, document");
          cacheWelcome.remove("TEMP_WELCOME_" + senderId);
          return;
        }
        let newWelcome = { type: type };
        if (type === "text") {
          newWelcome.content = parts[1].trim();
        } else {
          newWelcome.media = parts[1].trim();
          newWelcome.caption = parts.length >= 3 ? parts[2].trim() : "";
        }
        setWelcomeMessage(newWelcome);
        sendMessage(chatId, "Welcome message updated!");
        cacheWelcome.remove("TEMP_WELCOME_" + senderId);
        return;
      }
      const cacheFuzzy = CacheService.getScriptCache();
      const cachedChatId = cacheFuzzy.get("TEMP_FUZZY_" + senderId);
      if (cachedChatId !== null) {
        if (chatId > 0 || cachedChatId === chatId.toString()) {
          let fuzzyWords = getFuzzyBannedWords();
          if (fuzzyWords.indexOf(text) === -1) {
            fuzzyWords.push(text);
            setFuzzyBannedWords(fuzzyWords);
            Logger.log(`Added fuzzy banned word: ${text}`);
            sendMessage(chatId, `Fuzzy banned word "${text}" added.`);
          } else {
            sendMessage(chatId, `Fuzzy banned word "${text}" already exists.`);
          }
          cacheFuzzy.remove("TEMP_FUZZY_" + senderId);
          return;
        }
      }
      if (text.startsWith("/setpindelete")) {
        let parts = text.split(" ");
        if (parts.length < 2) {
          return sendMessage(chatId, "Format error: /setpindelete on/off [interval_minutes]");
        }
        let state = parts[1].toLowerCase();
        if (state === "on") {
          let interval = parts.length > 2 ? parseInt(parts[2], 10) : 60;
          if (isNaN(interval) || interval < 1) interval = 60;
          setPinAutoDeleteEnabled(true);
          setPinAutoDeleteInterval(interval);
          setupPinAutoDeleteTrigger();
          return sendMessage(chatId, `Pinned message auto-delete enabled, checking every ${interval} minutes.`);
        } else if (state === "off") {
          setPinAutoDeleteEnabled(false);
          deleteTriggers("deletePinnedMessages");
          return sendMessage(chatId, "Pinned message auto-delete disabled.");
        } else {
          return sendMessage(chatId, "Invalid parameter, use: /setpindelete on/off [interval_minutes]");
        }
      }
      if (text.startsWith("/setnightmode")) {
        let parts = text.split(" ");
        if (parts.length < 4 && parts[1] !== "off") {
          return sendMessage(chatId, "Format error: /setnightmode on start_time end_time or /setnightmode off\nE.g., /setnightmode on 22:00 07:00");
        }
        let state = parts[1].toLowerCase();
        if (state === "on") {
          let startTime = parts[2];
          let endTime = parts[3];
          if (!/^\d{2}:\d{2}$/.test(startTime) || !/^\d{2}:\d{2}$/.test(endTime)) {
            return sendMessage(chatId, "Time format error, use HH:MM, e.g., 22:00");
          }
          setNightModeEnabled(true);
          setNightModeStart(startTime);
          setNightModeEnd(endTime);
          return sendMessage(chatId, `Night mode enabled from ${startTime} to ${endTime} (timezone: ${getTimezone()}).`);
        } else if (state === "off") {
          setNightModeEnabled(false);
          return sendMessage(chatId, "Night mode disabled.");
        } else {
          return sendMessage(chatId, "Invalid parameter, use: /setnightmode on start_time end_time or /setnightmode off");
        }
      }
      if (text === "/settings" && senderId.toString() === BOT_CREATOR_ID) {
        return sendSettingsMenu(chatId);
      } else if (text === "/settings") {
        return sendMessage(chatId, "Only the bot creator can use this command.");
      }
    }

    // Group Event Handling - New Members (Fixed)
    if (message.new_chat_members) {
      const newMembers = message.new_chat_members;
      const isQuizVerificationEnabled = getQuizVerificationEnabled();

      if (!getWelcomeEnabled()) {
        deleteMessage(chatId, message_id);
        return;
      }

      let membersToWelcome = [];
      newMembers.forEach(function(member) {
        Logger.log(`New member: ID=${member.id}, Username=${member.username || 'None'}, IsBot=${member.is_bot}`);
        
        if (member.id === Number(BOT_ID)) {
          Logger.log(`Bot itself joined (ID=${BOT_ID}), skipping`);
          return;
        }

        const isMemberAdmin = isAdmin(chatId, member.id);
        const whitelist = getWhitelist();
        const isWhitelisted = whitelist.includes(member.id.toString());

        if (isQuizVerificationEnabled && !isMemberAdmin && !isWhitelisted) {
          Logger.log(`Triggering verification for user ${member.id}`);
          sendQuizVerification(chatId, member);
        } else {
          Logger.log(`No verification needed for user ${member.id} (Admin=${isMemberAdmin}, Whitelisted=${isWhitelisted})`);
          membersToWelcome.push(member);
        }
      });

      if (membersToWelcome.length > 0) {
        sendCustomWelcome(chatId, membersToWelcome);
      }

      deleteMessage(chatId, message_id);
      return;
    }

    // Other Group Events
    if (message.left_chat_member) {
      const name = message.left_chat_member.first_name;
      sendAutoDeleteMessage(chatId, `User ${name} left the group`, getEventAutoDeleteDuration());
      deleteMessage(chatId, message_id);
      return;
    }
    if (message.new_chat_title) {
      const newTitle = message.new_chat_title;
      sendAutoDeleteMessage(chatId, `Group name updated to: ${newTitle}`, getEventAutoDeleteDuration());
      deleteMessage(chatId, message_id);
      return;
    }

    // Violation Detection
    if (getFilterEnabled() && !(isSenderAdmin && getAdminExempt()) && !isWhitelisted) {
      if (message.forward_from_chat && message.forward_from_chat.type === "channel") {
        Logger.log("Detected forwarded message from channel");
        return handleViolation(chatId, senderId, message_id);
      }

      if (getForwardFilterEnabled() && message.forward_date) {
        let fwdContent = text || message.caption || "";
        if (fwdContent && isSpam(fwdContent)) {
          Logger.log("Detected spam in forwarded message");
          return handleViolation(chatId, senderId, message_id);
        }
      }
      if (text) {
        if (USER_LAST_MESSAGE[chatId] === text) return;
        USER_LAST_MESSAGE[chatId] = text;
        if (isSpam(text)) {
          Logger.log("Detected spam in text");
          return handleViolation(chatId, senderId, message_id);
        }
      }
      if (message.photo && getPornMediaFilterEnabled()) {
        let photoArray = message.photo;
        let largestPhoto = photoArray[photoArray.length - 1];
        let file_id = largestPhoto.file_id;
        if (analyzePhotoSafeSearch(file_id)) {
          Logger.log("Detected pornographic media");
          return handleViolation(chatId, senderId, message_id);
        }
      }
      if (message.video || message.animation) {
        let caption = message.caption;
        if (caption && isSpam(caption)) {
          Logger.log("Detected spam in video/animation caption");
          return handleViolation(chatId, senderId, message_id);
        }
      }
      if (message.document) {
        let fileName = message.document.file_name || "";
        if (/\.apk$/i.test(fileName)) {
          Logger.log("Detected APK file violation");
          return handleViolation(chatId, senderId, message_id);
        }
      }
      if (message.from && message.from.custom_emoji_sticker_set_name) {
        Logger.log("Detected custom emoji violation");
        return handleViolation(chatId, senderId, message_id);
      }
    }

    // Custom Reply Handling
    if (text) {
      const customReplies = getCustomReplies();
      if (customReplies[text]) {
        Logger.log("Matched custom reply: " + text);
        return sendCustomReply(chatId, customReplies[text]);
      } else if (text === "/help") {
        return sendHelpMessage(chatId);
      } else if (text === "/start") {
        return sendMenu(chatId);
      }
    }
  } catch (error) {
    Logger.log("❌ Error processing message: " + error.toString());
  }
}

// ========== Chat Member Update Handler ==========
function handleChatMemberUpdate(chatMemberUpdate) {
  const chatId = chatMemberUpdate.chat.id;
  const oldMember = chatMemberUpdate.old_chat_member;
  const newMember = chatMemberUpdate.new_chat_member;

  if (oldMember.user.first_name !== newMember.user.first_name ||
      oldMember.user.last_name !== newMember.user.last_name) {
    const userId = newMember.user.id;
    const oldName = oldMember.user.first_name + (oldMember.user.last_name ? " " + oldMember.user.last_name : "");
    const newName = newMember.user.first_name + (newMember.user.last_name ? " " + newMember.user.last_name : "");
    Logger.log(`User renamed: ${oldName} -> ${newName}`);

    const reminderText = `User ${oldName} renamed to ${newName}, beware of impersonation scams!`;
    const result = sendMessage(chatId, reminderText);
    if (result && result.ok && result.result && result.result.message_id) {
      const messageId = result.result.message_id;
      pinChatMessage(chatId, messageId);
    }
  }
}

// ========== Pin Message ==========
function pinChatMessage(chatId, messageId) {
  sendRequest("pinChatMessage", {
    chat_id: chatId,
    message_id: messageId,
    disable_notification: true
  });
}

// ========== Quiz Verification ==========
function sendQuizVerification(chatId, member) {
  const options = ["Apple", "Banana", "Orange", "Grape"];
  const correctIndex = Math.floor(Math.random() * options.length);
  const correctAnswer = options[correctIndex];
  const quizKey = "QUIZ_VERIFY_" + chatId + "_" + member.id;
  CacheService.getScriptCache().put(quizKey, correctAnswer, 300);

  const inlineKeyboard = options.map((opt, index) => [{
    text: opt,
    callback_data: `quiz_${chatId}_${member.id}_${index}`
  }]);

  const result = sendMessage(chatId, `Welcome ${member.first_name}! Answer within 5 minutes: Which is a fruit?`, {
    reply_markup: { inline_keyboard: inlineKeyboard }
  });

  if (result && result.ok && result.result && result.result.message_id) {
    CacheService.getScriptCache().put(quizKey + "_MSG", result.result.message_id, 300);
  }
}

// ========== Help Message ==========
function sendHelpMessage(chatId) {
  const helpText = `
**Usage Instructions**

**Basic Commands**
- **/help** - Show this help message
- **/start** - Display main menu
- **/settings** - Show settings panel (bot creator only)
- **/stats** - View group warning stats (admin only)
- **/clearwarnings** - Clear user warnings (admin only, reply or specify user ID)
- **/setpindelete on/off [minutes]** - Set pinned message auto-delete (admin only)
- **/setnightmode on start end or /setnightmode off** - Set night mode (admin only, e.g., /setnightmode on 22:00 07:00)
- **/settimezone timezone** - Set timezone (admin only, e.g., /settimezone Asia/Shanghai)
- **/addwhitelist userID** - Add user to whitelist (admin only)
- **/delwhitelist userID** - Remove user from whitelist (admin only)

**Custom Reply Management**
- **/addreply keyword|type|content[|caption]** - Add/update reply (e.g., /addreply button7|text|New reply)
- **/delreply keyword** - Delete reply

**Fuzzy Banned Words Management**
- Use settings panel "Fuzzy Banned Words" to view/add/delete
- **/delfuzzy word** - Delete specific fuzzy banned word

**Welcome Message Settings**
- Use "Set Welcome Message" in settings panel
- Format: type|content[|caption] (e.g., text|Welcome {names} to the group!)

**Violation Detection**
- Blocks all channel forwards
- Detects ads, links, porn, and fuzzy banned words
- Deletes message and warns; mutes after limit reached

**New Features**
- **Pinned Message Auto-Delete**: Schedule deletion with /setpindelete
- **Night Mode**: Auto-delete non-admin messages during set hours with /setnightmode
- **Media/Link-Only Night Mode**: Delete only media/links in settings panel
- **Quiz Verification**: New members answer a quiz, kicked if wrong
- **Timezone**: Set with /settimezone, defaults to Asia/Shanghai
- **Whitelist**: Manage exempt users with /addwhitelist and /delwhitelist
  `;
  sendMessage(chatId, helpText);
}

// ========== Custom Reply Sender ==========
function sendCustomReply(chatId, reply) {
  let markup = reply.inline_keyboard ? { inline_keyboard: reply.inline_keyboard } : undefined;
  let autoDuration = getReplyAutoDeleteDuration();
  switch (reply.type) {
    case "text":
      if (autoDuration > 0) {
        return sendAutoDeleteMessage(chatId, reply.content, autoDuration, { reply_markup: markup });
      }
      return sendMessage(chatId, reply.content, { reply_markup: markup });
    case "photo":
      if (autoDuration > 0) {
        let result = sendPhoto(chatId, reply.media, { caption: reply.caption, reply_markup: markup });
        if (result && result.ok && result.result && result.result.message_id) {
          Utilities.sleep(autoDuration * 1000);
          deleteMessage(chatId, result.result.message_id);
        }
        return result;
      }
      return sendPhoto(chatId, reply.media, { caption: reply.caption, reply_markup: markup });
    case "video":
      if (autoDuration > 0) {
        let result = sendVideo(chatId, reply.media, { caption: reply.caption, reply_markup: markup });
        if (result && result.ok && result.result && result.result.message_id) {
          Utilities.sleep(autoDuration * 1000);
          deleteMessage(chatId, result.result.message_id);
        }
        return result;
      }
      return sendVideo(chatId, reply.media, { caption: reply.caption, reply_markup: markup });
    case "document":
      if (autoDuration > 0) {
        let result = sendDocument(chatId, reply.media, { caption: reply.caption, reply_markup: markup });
        if (result && result.ok && result.result && result.result.message_id) {
          Utilities.sleep(autoDuration * 1000);
          deleteMessage(chatId, result.result.message_id);
        }
        return result;
      }
      return sendDocument(chatId, reply.media, { caption: reply.caption, reply_markup: markup });
    default:
      return sendMessage(chatId, "Unknown reply type");
  }
}

// ========== Welcome Message Sender ==========
function sendCustomWelcome(chatId, newMembers) {
  if (!getWelcomeEnabled()) return;
  let welcome = getWelcomeMessage();
  let names = newMembers.map(u => u.first_name).join(", ");
  let options = {};
  let autoDuration = getWelcomeAutoDeleteDuration();
  if (welcome.type === "text") {
    let textToSend = welcome.content.replace("{names}", names);
    if (autoDuration > 0) {
      sendAutoDeleteMessage(chatId, textToSend, autoDuration, options);
    } else {
      sendMessage(chatId, textToSend, options);
    }
  } else if (welcome.type === "photo") {
    options.caption = welcome.caption ? welcome.caption.replace("{names}", names) : "";
    if (autoDuration > 0) {
      let result = sendPhoto(chatId, welcome.media, { caption: options.caption });
      if (result && result.ok && result.result && result.result.message_id) {
        Utilities.sleep(autoDuration * 1000);
        deleteMessage(chatId, result.result.message_id);
      }
    } else {
      sendPhoto(chatId, welcome.media, { caption: options.caption });
    }
  } else if (welcome.type === "video") {
    options.caption = welcome.caption ? welcome.caption.replace("{names}", names) : "";
    if (autoDuration > 0) {
      let result = sendVideo(chatId, welcome.media, { caption: options.caption });
      if (result && result.ok && result.result && result.result.message_id) {
        Utilities.sleep(autoDuration * 1000);
        deleteMessage(chatId, result.result.message_id);
      }
    } else {
      sendVideo(chatId, welcome.media, { caption: options.caption });
    }
  } else if (welcome.type === "document") {
    options.caption = welcome.caption ? welcome.caption.replace("{names}", names) : "";
    if (autoDuration > 0) {
      let result = sendDocument(chatId, welcome.media, { caption: options.caption });
      if (result && result.ok && result.result && result.result.message_id) {
        Utilities.sleep(autoDuration * 1000);
        deleteMessage(chatId, result.result.message_id);
      }
    } else {
      sendDocument(chatId, welcome.media, { caption: options.caption });
    }
  }
}

// ========== Violation Detection and Handling ==========
function isSpam(text) {
  const spamRegex = new RegExp(`\\b(${SPAM_KEYWORDS.join("|")})\\b`, "i");
  const pornRegex = new RegExp(`\\b(${PORN_KEYWORDS.join("|")})\\b`, "i");
  if (spamRegex.test(text) || pornRegex.test(text) || LINK_PATTERN.test(text)) {
    Logger.log("Keyword or link detected");
    return true;
  }
  if (getFuzzyMatchEnabled()) {
    if (fuzzyContains(text, getFuzzyBannedWords(), FUZZY_THRESHOLD)) {
      Logger.log("Fuzzy match detected");
      return true;
    }
  }
  return false;
}

function handleViolation(chatId, userId, messageId) {
  if (!deleteMessage(chatId, messageId)) {
    Logger.log(`Failed to delete message ${messageId}`);
    return;
  }
  warnUser(chatId, userId);
}

function deleteMessage(chatId, messageId) {
  let result = sendRequest("deleteMessage", { chat_id: chatId, message_id: messageId });
  return result && result.ok;
}

function sendAutoDeleteMessage(chatId, text, autoDeleteSeconds, options = {}) {
  const result = sendMessage(chatId, text, options);
  if (result && result.ok && result.result && result.result.message_id && autoDeleteSeconds > 0) {
    Utilities.sleep(autoDeleteSeconds * 1000);
    deleteMessage(chatId, result.result.message_id);
  }
}

function warnUser(chatId, userId) {
  let count = getWarningCount(chatId, userId);
  count++;
  setWarningCount(chatId, userId, count);
  const autoDel = getPunishmentAutoDeleteDuration();
  if (count >= getWarningLimit()) {
    if (autoDel > 0) {
      sendAutoDeleteMessage(chatId, `⚠️ User ${userId} muted!`, autoDel);
    } else {
      sendMessage(chatId, `⚠️ User ${userId} muted!`);
    }
    restrictUser(chatId, userId);
    deleteWarningCount(chatId, userId);
  } else {
    if (autoDel > 0) {
      sendAutoDeleteMessage(chatId, `⚠️ Warning ${count}/${getWarningLimit()}: No violations allowed!`, autoDel);
    } else {
      sendMessage(chatId, `⚠️ Warning ${count}/${getWarningLimit()}: No violations allowed!`);
    }
  }
}

function restrictUser(chatId, userId) {
  const untilDate = Math.floor(Date.now() / 1000) + getMuteDuration();
  sendRequest("restrictChatMember", {
    chat_id: chatId,
    user_id: userId,
    until_date: untilDate,
    permissions: { can_send_messages: false }
  });
}

function kickUser(chatId, userId) {
  sendRequest("kickChatMember", {
    chat_id: chatId,
    user_id: userId
  });
}

// ========== Fuzzy Matching Utilities ==========
function levenshteinDistance(a, b) {
  const m = a.length, n = b.length;
  const dp = [];
  for (let i = 0; i <= m; i++) dp[i] = [i];
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (a.charAt(i - 1) === b.charAt(j - 1)) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, dp[i][j - 1] + 1, dp[i - 1][j] + 1);
      }
    }
  }
  return dp[m][n];
}

function fuzzyMatch(text, bannedWord, threshold) {
  text = text.toLowerCase();
  bannedWord = bannedWord.toLowerCase();
  const L = bannedWord.length;
  if (text.length < L) {
    const d = levenshteinDistance(text, bannedWord);
    return (d / L <= threshold);
  }
  for (let i = 0; i <= text.length - L; i++) {
    const sub = text.substring(i, i + L);
    const d = levenshteinDistance(sub, bannedWord);
    if (d / L <= threshold) return true;
  }
  return false;
}

function fuzzyContains(text, bannedWords, threshold) {
  for (let i = 0; i < bannedWords.length; i++) {
    if (fuzzyMatch(text, bannedWords[i], threshold)) return true;
  }
  return false;
}

// ========== Photo Safety Check (Google Cloud Vision API) ==========
function analyzePhotoSafeSearch(file_id) {
  let fileResponse = sendRequest("getFile", { file_id: file_id });
  if (!fileResponse || !fileResponse.ok) {
    Logger.log("Failed to get photo file");
    return false;
  }
  let filePath = fileResponse.result.file_path;
  let fileUrl = `https://api.telegram.org/file/bot${TOKEN}/${filePath}`;
  let imageResponse = UrlFetchApp.fetch(fileUrl);
  let imageBlob = imageResponse.getBlob();
  let base64Image = Utilities.base64Encode(imageBlob.getBytes());
  let visionApiKey = 'YOUR_VISION_API_KEY'; // Replace with your Google Vision API key
  let visionUrl = `https://vision.googleapis.com/v1/images:annotate?key=${visionApiKey}`;
  let requestPayload = {
    requests: [{
      image: { content: base64Image },
      features: [{ type: "SAFE_SEARCH_DETECTION" }]
    }]
  };
  let visionOptions = {
    method: "post",
    contentType: "application/json",
    payload: JSON.stringify(requestPayload)
  };
  try {
    let visionResponse = UrlFetchApp.fetch(visionUrl, visionOptions);
    let visionResult = JSON.parse(visionResponse.getContentText());
    if (visionResult.responses && visionResult.responses[0] && visionResult.responses[0].safeSearchAnnotation) {
      let safeSearch = visionResult.responses[0].safeSearchAnnotation;
      if (safeSearch.adult === "VERY_LIKELY" || safeSearch.adult === "LIKELY" ||
          safeSearch.violence === "VERY_LIKELY" || safeSearch.violence === "LIKELY" ||
          safeSearch.racy === "VERY_LIKELY" || safeSearch.racy === "LIKELY") {
        Logger.log("Detected inappropriate image");
        return true;
      }
    }
  } catch (err) {
    Logger.log("analyzePhotoSafeSearch error: " + err.toString());
  }
  return false;
}

// ========== Menu and Settings Panel ==========
function sendMenu(chatId) {
  sendMessage(chatId, "Please select an option:", {
    reply_markup: {
      inline_keyboard: [
        [{ text: "Button 1", callback_data: "按钮1" }, { text: "Button 2", callback_data: "按钮2" }],
        [{ text: "Button 3", callback_data: "按钮3" }, { text: "Button 4", callback_data: "按钮4" }],
        [{ text: "Button 5", callback_data: "按钮5" }, { text: "Button 6", callback_data: "按钮6" }],
        [{ text: "Back to Main Menu", callback_data: "返回主菜单" }]
      ]
    }
  });
  sendKeyboard(chatId);
}

function sendSettingsMenu(chatId) {
  sendMessage(chatId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
}

function buildSettingsMarkup() {
  return {
    inline_keyboard: [
      [
        { text: `Violation Detection: ${getFilterEnabled() ? "✅" : "❌"}`, callback_data: "toggle_filter" },
        { text: `Fuzzy Banned Words: ${getFuzzyMatchEnabled() ? "✅" : "❌"}`, callback_data: "toggle_fuzzy" }
      ],
      [
        { text: `Forward Filter: ${getForwardFilterEnabled() ? "✅" : "❌"}`, callback_data: "toggle_forward_filter" },
        { text: `Porn Media: ${getPornMediaFilterEnabled() ? "✅" : "❌"}`, callback_data: "toggle_porn_media" }
      ],
      [
        { text: `Welcome Message: ${getWelcomeEnabled() ? "✅" : "❌"}`, callback_data: "toggle_welcome" },
        { text: "Set Welcome Message", callback_data: "manage_welcome" }
      ],
      [
        { text: "Keyword Replies", callback_data: "manage_replies" },
        { text: "Fuzzy Banned Words", callback_data: "manage_fuzzy" }
      ],
      [
        { text: `Mute Duration: ${formatDuration(getMuteDuration())}`, callback_data: "cycle_mute_duration" },
        { text: `Warning Limit: ${getWarningLimit()}`, callback_data: "cycle_warning_limit" }
      ],
      [
        { text: `Punishment Notice: ${getPunishmentAutoDeleteDuration()}s`, callback_data: "cycle_punishment_auto_delete" },
        { text: `Group Notice: ${getEventAutoDeleteDuration()}s`, callback_data: "cycle_event_auto_delete" }
      ],
      [
        { text: `Exempt Admins: ${getAdminExempt() ? "✅" : "❌"}`, callback_data: "toggle_admin_exempt" },
        { text: `Quiz Verification: ${getQuizVerificationEnabled() ? "✅" : "❌"}`, callback_data: "toggle_quiz_verification" }
      ],
      [
        { text: `Welcome Auto-Delete: ${getWelcomeAutoDeleteDuration()}s`, callback_data: "cycle_welcome_autodelete" },
        { text: `Reply Auto-Delete: ${getReplyAutoDeleteDuration()}s`, callback_data: "cycle_reply_autodelete" }
      ],
      [
        { text: `Pin Delete: ${getPinAutoDeleteEnabled() ? "✅" : "❌"}`, callback_data: "toggle_pin_delete" },
        { text: `Night Mode: ${getNightModeEnabled() ? "✅" : "❌"}`, callback_data: "toggle_night_mode" }
      ],
      [
        { text: `Media/Link Night: ${getOnlyMediaLinkNightModeEnabled() ? "✅" : "❌"}`, callback_data: "toggle_only_media_link_night" },
        { text: "My Groups", callback_data: "show_groups" }
      ],
      [
        { text: "Whitelist Management", callback_data: "manage_whitelist" },
        { text: "Back to Main Menu", callback_data: "返回主菜单" }
      ]
    ]
  };
}

function sendKeyboard(chatId) {
  sendMessage(chatId, "Please select an input option:", {
    reply_markup: {
      keyboard: [
        ["Option A", "Option B"],
        ["Option C", "Option D"],
        ["Option E", "Back to Main Menu"]
      ],
      resize_keyboard: true,
      one_time_keyboard: false
    }
  });
}

// ========== Keyword Reply Management Menu ==========
function sendReplySettingsMenu(chatId) {
  const customReplies = getCustomReplies();
  let replyText = "**Current Keyword Replies**\n";
  for (let key in customReplies) {
    if (customReplies.hasOwnProperty(key)) {
      let r = customReplies[key];
      replyText += `\nKeyword: ${key}\nType: ${r.type}\nContent: ${r.type === "text" ? r.content : r.media}\n`;
    }
  }
  replyText += "\n**Management Tips**\n- Add/Update: /addreply keyword|type|content[|caption]\n- Delete: /delreply keyword\n(Types: text, photo, video, document)";
  let markup = {
    inline_keyboard: [
      [{ text: "Refresh List", callback_data: "refresh_replies" }],
      [{ text: "Back to Settings", callback_data: "back_settings" }]
    ]
  };
  sendMessage(chatId, replyText, { reply_markup: markup });
}

// ========== Fuzzy Banned Words Management Menu ==========
function sendFuzzySettingsMenu(chatId) {
  const fuzzyWords = getFuzzyBannedWords();
  let replyText = "**Current Fuzzy Banned Words**\n";
  if (fuzzyWords.length === 0) {
    replyText += "No fuzzy banned words.\n";
  } else {
    fuzzyWords.forEach(word => { replyText += `- ${word}\n`; });
  }
  replyText += "\n**Management Tips**\nClick buttons below to delete, or 'Add Fuzzy Banned Word' to add.";
  let inlineKeyboard = [];
  if (fuzzyWords.length > 0) {
    fuzzyWords.forEach(word => {
      inlineKeyboard.push([{ text: `Delete [${word}]`, callback_data: "del_fuzzy:" + encodeURIComponent(word) }]);
    });
  }
  inlineKeyboard.push([{ text: "Add Fuzzy Banned Word", callback_data: "add_fuzzy" }]);
  inlineKeyboard.push([{ text: "Refresh List", callback_data: "manage_fuzzy" }]);
  inlineKeyboard.push([{ text: "Back to Settings", callback_data: "back_settings" }]);
  sendMessage(chatId, replyText, { reply_markup: { inline_keyboard: inlineKeyboard } });
}

// ========== Welcome Message Settings Menu ==========
function sendWelcomeSettingsMenu(chatId) {
  let welcome = getWelcomeMessage();
  let msg = "**Current Welcome Message Settings**\n";
  msg += `Type: ${welcome.type}\n`;
  if (welcome.type === "text") {
    msg += `Content: ${welcome.content}\n`;
  } else {
    msg += `Media: ${welcome.media}\n`;
    msg += `Caption: ${welcome.caption || ""}\n`;
  }
  msg += "\n**Management Tips**\nClick 'Edit Welcome Message' to send new config.\nFormat: type|content[|caption]\nE.g., text|Welcome {names} to the group!\nOr photo|https://example.com/welcome.jpg|Welcome {names}!";
  let markup = {
    inline_keyboard: [
      [{ text: "Edit Welcome Message", callback_data: "edit_welcome" }],
      [{ text: "Back to Settings", callback_data: "back_settings" }]
    ]
  };
  sendMessage(chatId, msg, { reply_markup: markup });
}

// ========== Whitelist Management Menu ==========
function sendWhitelistSettingsMenu(chatId) {
  const whitelist = getWhitelist();
  let replyText = "**Current Whitelist**\n";
  if (whitelist.length === 0) {
    replyText += "No whitelisted users.\n";
  } else {
    whitelist.forEach(userId => { replyText += `- ${userId}\n`; });
  }
  replyText += "\n**Management Tips**\n- Add: /addwhitelist userID\n- Delete: Click below or use /delwhitelist userID";
  let inlineKeyboard = [];
  if (whitelist.length > 0) {
    whitelist.forEach(userId => {
      inlineKeyboard.push([{ text: `Delete [${userId}]`, callback_data: "del_whitelist:" + userId }]);
    });
  }
  inlineKeyboard.push([{ text: "Refresh List", callback_data: "manage_whitelist" }]);
  inlineKeyboard.push([{ text: "Back to Settings", callback_data: "back_settings" }]);
  sendMessage(chatId, replyText, { reply_markup: { inline_keyboard: inlineKeyboard } });
}

// ========== Callback Handler ==========
function handleCallback(query) {
  sendRequest("answerCallbackQuery", { callback_query_id: query.id });
  const chatId = query.message.chat.id;
  const messageId = query.message.message_id;
  const data = query.data;
  const senderId = query.from.id;

  if (senderId.toString() !== BOT_CREATOR_ID && (
      data === "toggle_filter" || data === "toggle_fuzzy" || data === "toggle_forward_filter" ||
      data === "toggle_porn_media" || data === "toggle_welcome" || data === "manage_welcome" ||
      data === "toggle_admin_exempt" || data === "toggle_quiz_verification" || data === "cycle_welcome_autodelete" ||
      data === "cycle_reply_autodelete" || data === "cycle_mute_duration" || data === "cycle_warning_limit" ||
      data === "cycle_punishment_auto_delete" || data === "cycle_event_auto_delete" || data === "manage_replies" ||
      data === "manage_fuzzy" || data === "edit_welcome" || data === "add_fuzzy" || data.startsWith("del_fuzzy:") ||
      data === "refresh_replies" || data === "back_settings" || data === "toggle_pin_delete" ||
      data === "toggle_night_mode" || data === "toggle_only_media_link_night" || data === "manage_whitelist" ||
      data.startsWith("del_whitelist:")
  )) {
    sendMessage(chatId, "Only the bot creator can modify settings.");
    return;
  }

  if (data.startsWith("quiz_")) {
    const [_, chatIdStr, userIdStr, answerIndex] = data.split("_");
    const userId = parseInt(userIdStr);
    const quizKey = "QUIZ_VERIFY_" + chatId + "_" + userId;
    const correctAnswer = CacheService.getScriptCache().get(quizKey);
    const msgKey = quizKey + "_MSG";
    const msgId = CacheService.getScriptCache().get(msgKey);

    if (msgId) deleteMessage(chatId, msgId);

    if (correctAnswer) {
      const options = ["Apple", "Banana", "Orange", "Grape"];
      const selectedAnswer = options[parseInt(answerIndex)];
      if (selectedAnswer === correctAnswer) {
        sendCustomWelcome(chatId, [{ id: userId, first_name: query.from.first_name }]);
        CacheService.getScriptCache().remove(quizKey);
        CacheService.getScriptCache().remove(msgKey);
      } else {
        kickUser(chatId, userId);
        sendAutoDeleteMessage(chatId, `User ${query.from.first_name} answered incorrectly and was removed`, 10);
        CacheService.getScriptCache().remove(quizKey);
        CacheService.getScriptCache().remove(msgKey);
      }
    } else {
      sendMessage(chatId, "Verification timed out or invalid");
    }
    return;
  }

  if (data === "manage_welcome") {
    sendWelcomeSettingsMenu(chatId);
  } else if (data === "toggle_filter") {
    setSetting("FILTER_ENABLED", !getFilterEnabled());
    editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
  } else if (data === "toggle_fuzzy") {
    setSetting("FUZZY_MATCH_ENABLED", !getFuzzyMatchEnabled());
    editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
  } else if (data === "toggle_forward_filter") {
    setSetting("FORWARD_FILTER_ENABLED", !getForwardFilterEnabled());
    editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
  } else if (data === "toggle_porn_media") {
    setSetting("PORN_MEDIA_FILTER_ENABLED", !getPornMediaFilterEnabled());
    editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
  } else if (data === "toggle_welcome") {
    setWelcomeEnabled(!getWelcomeEnabled());
    editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
  } else if (data === "toggle_admin_exempt") {
    setAdminExempt(!getAdminExempt());
    editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
  } else if (data === "toggle_quiz_verification") {
    setQuizVerificationEnabled(!getQuizVerificationEnabled());
    editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
  } else if (data === "cycle_welcome_autodelete") {
    cycleWelcomeAutoDelete(chatId, messageId);
  } else if (data === "cycle_reply_autodelete") {
    cycleReplyAutoDelete(chatId, messageId);
  } else if (data === "cycle_mute_duration") {
    cycleMuteDuration(chatId, messageId);
  } else if (data === "cycle_warning_limit") {
    cycleWarningLimit(chatId, messageId);
  } else if (data === "cycle_punishment_auto_delete") {
    cyclePunishmentAutoDelete(chatId, messageId);
  } else if (data === "cycle_event_auto_delete") {
    cycleEventAutoDelete(chatId, messageId);
  } else if (data === "manage_replies") {
    sendReplySettingsMenu(chatId);
  } else if (data === "manage_fuzzy") {
    sendFuzzySettingsMenu(chatId);
  } else if (data === "manage_whitelist") {
    sendWhitelistSettingsMenu(chatId);
  } else if (data === "edit_welcome") {
    const cache = CacheService.getScriptCache();
    cache.put("TEMP_WELCOME_" + query.from.id, chatId.toString(), 300);
    sendMessage(chatId, "Send new welcome config.\nFormat: type|content[|caption]\nE.g., text|Welcome {names}!\nOr photo|https://example.com/welcome.jpg|Welcome {names}!");
  } else if (data === "add_fuzzy") {
    const cache = CacheService.getScriptCache();
    cache.put("TEMP_FUZZY_" + query.from.id, chatId.toString(), 300);
    sendMessage(chatId, "Send the fuzzy banned word to add.");
  } else if (data.startsWith("del_fuzzy:")) {
    let wordEncoded = data.substring("del_fuzzy:".length);
    let word = decodeURIComponent(wordEncoded);
    let fuzzyWords = getFuzzyBannedWords();
    let index = fuzzyWords.indexOf(word);
    if (index !== -1) {
      fuzzyWords.splice(index, 1);
      setFuzzyBannedWords(fuzzyWords);
      sendMessage(chatId, `Fuzzy banned word "${word}" deleted`);
    } else {
      sendMessage(chatId, `Fuzzy banned word "${word}" not found`);
    }
    sendFuzzySettingsMenu(chatId);
  } else if (data.startsWith("del_whitelist:")) {
    let userId = data.substring("del_whitelist:".length);
    let whitelist = getWhitelist();
    let index = whitelist.indexOf(userId);
    if (index !== -1) {
      whitelist.splice(index, 1);
      setWhitelist(whitelist);
      sendMessage(chatId, `User ${userId} removed from whitelist`);
    } else {
      sendMessage(chatId, `User ${userId} not in whitelist`);
    }
    sendWhitelistSettingsMenu(chatId);
  } else if (data === "refresh_replies") {
    sendReplySettingsMenu(chatId);
  } else if (data === "back_settings") {
    sendSettingsMenu(chatId);
  } else if (data === "show_groups") {
    showGroupList(chatId);
  } else if (data === "toggle_pin_delete") {
    let newState = !getPinAutoDeleteEnabled();
    setPinAutoDeleteEnabled(newState);
    setupPinAutoDeleteTrigger();
    editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
    sendMessage(chatId, `Pinned message auto-delete ${newState ? "enabled" : "disabled"}, interval: ${getPinAutoDeleteInterval()} minutes.`);
  } else if (data === "toggle_night_mode") {
    let newState = !getNightModeEnabled();
    setNightModeEnabled(newState);
    editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
    sendMessage(chatId, `Night mode ${newState ? "enabled" : "disabled"}, ${getNightModeStart()} - ${getNightModeEnd()} (timezone: ${getTimezone()}).`);
  } else if (data === "toggle_only_media_link_night") {
    let newState = !getOnlyMediaLinkNightModeEnabled();
    setOnlyMediaLinkNightModeEnabled(newState);
    editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
    sendMessage(chatId, `Media/Link night mode ${newState ? "enabled" : "disabled"}, ${getNightModeStart()} - ${getNightModeEnd()} (timezone: ${getTimezone()}).`);
  } else {
    const customReplies = getCustomReplies();
    if (customReplies[data]) {
      sendCustomReply(chatId, customReplies[data]);
    } else {
      sendMessage(chatId, "Custom reply not found: " + data);
    }
  }
}

function cycleMuteDuration(chatId, messageId) {
  const durations = [3600, 21600, 86400];
  let current = getMuteDuration();
  let idx = durations.indexOf(current);
  if (idx === -1) idx = 0;
  let newDuration = durations[(idx + 1) % durations.length];
  setSetting("MUTE_DURATION", newDuration);
  editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
}

function cycleWarningLimit(chatId, messageId) {
  const limits = [1, 2, 3, 5];
  let current = getWarningLimit();
  let idx = limits.indexOf(current);
  if (idx === -1) idx = 2;
  let newLimit = limits[(idx + 1) % limits.length];
  setSetting("WARNING_LIMIT", newLimit);
  editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
}

function cyclePunishmentAutoDelete(chatId, messageId) {
  const durations = [0, 5, 10, 20, 30];
  let current = getPunishmentAutoDeleteDuration();
  let idx = durations.indexOf(current);
  if (idx === -1) idx = 2;
  let newDuration = durations[(idx + 1) % durations.length];
  setSetting("PUNISHMENT_AUTO_DELETE", newDuration);
  editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
}

function cycleEventAutoDelete(chatId, messageId) {
  const durations = [0, 5, 10, 20, 30];
  let current = getEventAutoDeleteDuration();
  let idx = durations.indexOf(current);
  if (idx === -1) idx = 2;
  let newDuration = durations[(idx + 1) % durations.length];
  setSetting("EVENT_AUTO_DELETE", newDuration);
  editMessage(chatId, messageId, "⚙️ Settings Panel:", { reply_markup: buildSettingsMarkup() });
}

function formatDuration(seconds) {
  return (seconds / 3600) + " hours";
}

// ========== Admin Check ==========
function isAdmin(chatId, userId) {
  if (chatId > 0) return true; // Private chats treated as admin
  let cache = CacheService.getScriptCache();
  let key = `ADMIN_${chatId}_${userId}`;
  let cached = cache.get(key);
  if (cached !== null) return cached === "true";
  try {
    let response = UrlFetchApp.fetch(`${BASE_URL}getChatMember?chat_id=${chatId}&user_id=${userId}`);
    let data = JSON.parse(response.getContentText());
    let isAdmin = data.ok && (data.result.status === "creator" || data.result.status === "administrator");
    cache.put(key, isAdmin.toString(), 3600);
    return isAdmin;
  } catch (error) {
    Logger.log("isAdmin check error: " + error.toString());
    return false; // Default to non-admin on error to trigger verification
  }
}

// ========== Message Sending and Editing ==========
function sendRequest(method, payload) {
  try {
    let response = UrlFetchApp.fetch(`${BASE_URL}${method}`, {
      method: "post",
      contentType: "application/json",
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    });
    let result = JSON.parse(response.getContentText());
    if (!result.ok) {
      Logger.log(`Error in ${method}: ${result.description}`);
      return null;
    }
    return result;
  } catch (err) {
    Logger.log(`Exception in ${method}: ${err.toString()}`);
    return null;
  }
}

function sendMessage(chatId, text, options = {}) {
  return sendRequest("sendMessage", { chat_id: chatId, text: text, ...options });
}

function sendPhoto(chatId, photoUrl, options = {}) {
  return sendRequest("sendPhoto", { chat_id: chatId, photo: photoUrl, ...options });
}

function sendVideo(chatId, videoUrl, options = {}) {
  return sendRequest("sendVideo", { chat_id: chatId, video: videoUrl, ...options });
}

function sendDocument(chatId, documentUrl, options = {}) {
  return sendRequest("sendDocument", { chat_id: chatId, document: documentUrl, ...options });
}

function editMessage(chatId, messageId, text, options = {}) {
  sendRequest("editMessageText", { chat_id: chatId, message_id: messageId, text: text, ...options });
}

// ========== Webhook Setup ==========
function setWebhook() {
  const url = `${BASE_URL}setWebhook`;
  const params = {
    url: SCRIPT_URL,
    allowed_updates: JSON.stringify(["message", "chat_member", "callback_query"])
  };
  const options = {
    method: "post",
    payload: params,
    muteHttpExceptions: true
  };
  const response = UrlFetchApp.fetch(url, options);
  const result = JSON.parse(response.getContentText());
  if (result.ok) {
    Logger.log("Webhook set successfully");
  } else {
    Logger.log("Failed to set webhook: " + result.description);
  }
}